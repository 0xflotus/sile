\begin[papersize=a4,class=book]{document}
\script[src=packages/grid]
\script[src=packages/verbatim]
\script[src=packages/color]
\script[src=packages/image]
\script[src=packages/frametricks]
\script[src=packages/lorem]
\include[src=documentation/macros.sil]
\define[command=silehp]{\code{http://github.com/simoncozens/sile}}
\font[size=11pt,family=Gentium Book Basic]
\nofolios
%\set[parameter=document.lskip,value=5em]
%\set[parameter=document.rskip,value=5em]
\font[size=50pt,weight=600,family=Helvetica Neue]{\hss The SILE Book \hss \par}
\bigskip[height=3in]
\font[size=20pt,weight=600,family=Helvetica Neue]{\hss Simon Cozens \hss \par}

%\set[parameter=document.lskip,value=0]
%\set[parameter=document.rskip,value=0]
\set[parameter=document.parskip,value=4pt plus 1pt]
\open-double-page
\tableofcontents

\set-counter[id=folio,value=0]
\chapter{What is SILE?}

SILE is a typesetting system. Its job is to produce beautiful printed
documents. The best way to understand what SILE is and what it does is
to compare it to other systems which you may have heard of.

\section{SILE versus Word}

When most people produce printed documents using a computer, they 
usually use software such as Word (part of Microsoft Office) or Writer
(part of Open/LibreOffice) or similar–word processing software. SILE is
not a word processor; it is a typesetting system. There are
several important differences.

The job of a word processor is to produce a document that looks exactly like what you type on the screen. SILE takes what you type and considers it instructions for producing a document that looks as good as possible.

For instance, in a word processor, you keep typing and when you hit the right margin, your cursor will move to the next line. It is showing you where the lines will break. SILE doesn’t show you where the lines will break, because it doesn’t know yet. You can type and type and type as long a line as you like, and when SILE comes to process your instructions, it will consider your input (up to) three times over in order to work out how to best to break the lines to form a paragraph. Did we end two successive lines with a hyphenated word? Go back and try again.

Similarly for page breaks. When you type into a word processor, at some point you will spill over onto a new page. In SILE, you keep typing, because the page breaks are determined after considering the layout of the whole document.

Word processors often describe themselves as WYSIWYG–What You See Is What You
Get. SILE is cheerfully \em{not} WYSIWYG. In fact, you don’t see what you get until
you get it. Rather, SILE documents are prepared initially in a \em{text editor}–a
piece of software which focuses on the text itself and not what it looks like–and then
ran through SILE in order to produce a PDF document.

In other words, SILE is a \em{language} for describing
what you want to happen, and SILE will make certain formatting decisions about the
best way for those instructions to be turned into print.

\section{SILE versus TeX}

Ah, some people will say, that sounds very much like TeX.\footnote{Except that,
being TeX users, they will say “Ah, that sounds very much like T\glue[width=-.1667em]\lower[height=0.5ex]{E}\glue[width=-.125em]X”.} If you don’t know much about TeX or
don’t care, you can probably skip this section.

But it’s true. SILE owes an awful lot of its heritage to TeX. It would be terribly
immodest to claim that a little project like SILE was a worthy successor to the
ancient and venerable creation of the Professor of the Art of Computer Programming,
but… really, SILE is basically a modern rewrite of TeX.

TeX was one of the earliest typesetting systems, and had to make a lot of
design decisions somewhat in a vacuum. Some of those design decisions have stood
the test of time–and TeX is still an extremely well-used typesetting system more
than thirty years after its inception, which is a testament to its design and
performance–but many others have not. In fact, most of the development of TeX since
Knuth’s era has involved removing his early decisions and replacing them with
technologies which have become the industry standard:
we use TrueType fonts, not METAFONTs (xetex); PDFs,
not DVIs (pstex, pdftex); Unicode, not 7-bit ASCII (xetex again); markup languages and embedded programming 
languages, not macro languages (xmltex, luatex).  At this point, the parts of TeX
that people actually \em{use} are 1) the box-and-glue model, 2) the hyphenation algorithm,
and 3) the line-breaking algorithm.

SILE follows TeX in each of these three areas; it contains a slavish port of the
TeX line-breaking algorithm which has been tested to produce exactly the same output
as TeX given equivalent input. But as SILE is itself written in an interpreted
language,\footnote{And if the phrase \code{TeX capacity exceeded} is familiar to you,
you should already be getting excited.} it is very easy to extend or alter the
behaviour of the SILE typesetter.

For instance, one of the things that TeX can’t do particularly well is typesetting
on a grid. This is something that people typesetting bibles really need to have.
There are various hacks to try to make it happen, but they’re all horrible. In SILE,
you can alter the behaviour of the typesetter and write a very short add-on package
to enable grid typesetting.

Of course, nobody uses plain TeX–they all use LaTeX equivalents plus a huge repository
of packages available from the CTAN. SILE does not benefit from the large ecosystem 
and community that has grown up around TeX; in that sense, TeX will remain streets
ahead of SILE for some time to come. But in terms of \em{capabilities}, SILE is
already certainly equivalent to, if not somewhat more advanced than, TeX.

\section{SILE versus InDesign}

The other tool that people reach for when designing printed material on a computer is
InDesign.

InDesign is a complex, expensive, commercial publishing tool. It’s highly 
graphical–you click and drag to move areas of text and images around the screen. 
SILE is a free, open source typesetting tool which is entirely text-based; you
enter commands in a separate editing tool, save those commands into a file, and hand it to SILE for typesetting. And yet the two
systems do have a number of common features.

\float[rightboundary=7pt, bottomboundary=15pt]{\img[src=documentation/fig1.png,width=110]} 
In InDesign, text is flowed into \em{frames} on the page. On the
left, you can see an example of what
a fairly typical InDesign layout might look like.

SILE also uses the concept of frames to determine where text should appear on
the page, and so it’s possible to use SILE to generate page layouts which are
more flexible and more complex than that afforded by TeX.

Another thing which people use InDesign for is to turn structured data in XML
format–catalogues, directories and the like–into print. The way you do this
in InDesign is to declare what styling should apply to each XML element, and as the
data is read in, InDesign formats the content according to the rules that you
have declared.\supereject

You can do exactly the same thing in SILE, except you have a lot more control
over how the XML elements get styled, because you can run any SILE command you
like for a given element, including calling out to Lua code to style a piece of 
XML. Since SILE is a command-line filter, armed with appropriate styling
instructions you can go from an XML file to a PDF in one shot. Which is quite nice.

In the final chapters of this book, we’ll look at some extended examples of creating
a \em{class file} for styling a complex XML document into a PDF with SILE.

\section{Conclusion}

SILE takes some textual instructions and turns them into PDF output.
It has features inspired by TeX and InDesign, but seeks to be more flexible,
extensible and programmable than them. It’s useful both for typesetting
documents such as this one written in the SILE language, and as a processing
system for styling and outputting structured data.

\chapter{Getting Started}

Now that we understand some of what SILE is about and what it seeks to do, 
let’s dive into SILE itself.

\section{A Basic SILE Document}

Before we even show you how to use SILE, let’s have a look at an
example of what SILE documents look like. This is the input that we’re
going to feed to SILE, which it is going to process and turn into a PDF
file. 

\note{These documents are plain text files; when you create your own
SILE files, you will need to create them in a plain text editor such
as \em{vi} or \em{emacs} on Unix, Sublime Text, TextMate or TextEdit on 
OS X, or Notepad or Notepad+ on Windows, save them as a text file and
then use them as input to SILE. Trying to create these files in a 
word processor such as Word will not work, as they will not be saved 
with the word processor’s formatting, rather than in a plain text format.}

To begin with, here’s the most basic SILE file of all:

\begin{verbatim}
\line
\\begin[papersize=a4]\{document\}
Hello SILE!
\\end\{document\}
\line
\end{verbatim}

We’ll pick apart this document in the next chapter, but for now take it on
trust that this is what a SILE document looks like.

At risk of belabouring the obvious, this is going to produce an A4-sized
PDF document, with the text \examplefont{Hello SILE} at the top left, and the page
number (1) centered at the bottom. How are we going to get to that PDF?

\section{Installing}

First of all, we need to get hold of SILE and get it running on our computer.
Downloads of SILE can be obtained from the home page at \silehp.

SILE requires a number of other software packages to be installed on the 
computer before it can work—Cairo, Pango and Lua. On OS X machines running
Homebrew (always a good idea for OS X machines), you will need to run

• \code{brew install cairo pango lua luarocks}

On DEB-based Linux machines such as Debian and Ubuntu, try

• \code{apt-get install libcairo-gobject2 libpango1.0-0 lua5.1 luarocks}

Once these dependencies are installed, you also need to install some
Lua libraries:

• \code{luarocks install stdlib lgi lpeg luaexpat inspect luaepnf luarepl cassowary}

Now we should be finally really to go. Unpack the file that you downloaded
from SILE’s home page, and change to that directory. You can now run SILE as
is, uninstalled:

• \code{./sile examples/simple.sil}

If all has gone well, this should produce a file \code{examples/simple.pdf}.

Most users of SILE will want to install the \code{sile} command and SILE’s
library files onto their system; this can be done with

• \code{lua install.lua}

Now the \code{sile} command is available from any directory.

\section{Running SILE}

Let’s move to a new directory, and in a text editor, create the file \code{hello.sil}.
Copy in the content above and save the file. Now at your command line run:

• \code{sile hello}

(SILE will automatically provide the extension \code{.sil} to input files if it
is not provided by the user.)

Once again, this should produce an output file \code{hello.pdf}. Congratulations–you
have just typeset your first document with SILE.

\section{Let’s Do Something Cool}

In \code{examples/article-template.xml}, you will find a typical DocBook 5.0
article. Normally turning DocBook to print involves a curious dance of XSLT
processors, format object processors and/or strange LaTeX packages. But SILE
can read XML files and it also comes with a \code{docbook} class, which tells SILE
how to render (admittedly, a subset of) the DocBook tags onto a page.

Turning \code{examples/article-template.xml} into \code{examples/article-template.pdf}
is now as simple as:

\begin{verbatim}
\line
\% \em{./sile -I docbook examples/article-template.xml}
This is SILE 0.9.0
Loading docbook
<classes/docbook.sil><examples/article-template.xml>[1] [2] [3]
\line
\end{verbatim}

The \code{-I} flag loads up a \em{class} before reading the input file; after
this has been loaded, the DocBook file can be read directly and its tags interpreted
as SILE commands.

In Chapter 10, we’ll look at how the \code{docbook} class works, and how you 
can define processing expectations for other XML formats.

\chapter{SILE’s Input Language}

Let’s now go back and reconsider the first SILE file we saw:

\begin{verbatim}
\line
\\begin[papersize=a4]\{document\}
Hello SILE!
\\end\{document\}
\line
\end{verbatim}

A document starts with a 
\code{\\begin\{document\}} command, which \em{must} define the paper size,
and ends with \code{\\end\{document\}}. In between, SILE documents are made 
up of two elements: text to be typeset on the page, such as “Hello SILE!”
in our example, and commands. 

\note{\notehead{Paper sizes}
SILE knows about the ISO standard A, B and C
series paper sizes, as well as the following traditional sizes:
  letter, note, legal, executive, halfletter, halfexecutive, statement, folio, quarto, ledger, tabloid.

If you need a paper size for your document which is not one of the standards,
then you can specify it by dimensions: \code{papersize=\em{<basic length> x <basic length>}}.

\smallskip\notehead{Dimensions}\par
SILE knows a number of ways of specifying lengths. A \code{<basic length>} as
mentioned above can be specified as a floating-point number followed by a dimension
abbreviation. Acceptable dimensions are printer’s points (\code{pt}), 
millimeters (\code{mm}), centimeters (\code{cm}) or inches. (\code{in}) For instance
a standard B-format book can be specified \code{papersize=198mm x 129mm}.
Later we will meet some other ways of specifying lengths.
}
\section{Ordinary text}

 On the whole, ordinary text isn’t particularly interesting–it’s
just typeset. 

\note{TeX users may have an expectation that SILE will do certain things with
ordinary text as well. For instance, if you place two straight-backquotes
into a TeX document (like this: \code{``}) then TeX will magically turn that
into a double opening quote (“). SILE won’t do this. If you want a double
opening quote, you have to ask for one. Similarly, en- and em-dashes have
to be input as actual Unicode en- and em-dashes, rather than \code{--} or
\code{---} respectively.}

There are only a few bits of cleverness that happen around ordinary text.

The first is that space is not particularly significant. If you write
\code{Hello {} {} SILE!} with three spaces, you get the same output as if
you write \code{Hello SILE!} with just one.

Similarly, you can place a line break anywhere you like in the input file,
and it won’t affect the output because SILE considers each paragraph
at a time and computes the appropriate line breaks for the paragraph based
on the width of the line available. In other words, if your input file
says

\begin{verbatim}
\line
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
\line
\end{verbatim}

you might not necessarily get a line break after ‘eiusmod’; you’ll get a line
break wherever is most appropriate. In the context of this document, you’ll
get:

\line
\nohyphenation{\examplefont{Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.}}
\line

When you want to end a paragraph, you need to input two line breaks in a row,
like this:

\begin{verbatim}
\line
Paragraph one.
 
Paragraph two.
This is not paragraph three.
 
This is paragraph three.
\line
\end{verbatim}

The second clever thing that happens around ordinary text is that a few–four,
in fact–characters have a special meaning to SILE. All of these will be familiar
to TeX users.

We’ve seen that a \em{backslash} is
used to start a command, and we’ll look into commands in more detail soon.
\em{Left and right curly braces} (\code{\{}, \code{\}}) are used for grouping,
particularly in command arguments. Finally, a \em{percent sign} is used as a comment
character, meaning that everything from the percent to the end of the line is
ignored by SILE. If you want to actually typeset these characters, prepend
a backslash to them: \code{\\\\} produces ‘\\’, \code{\\\{} produces ‘\{’, 
\code{\\\}} produces ‘\}’, and \code{\\\%} produces ‘\%’.

The third clever thing is SILE will 
automatically hyphenate text at the end of a line if it feels this will
make the paragraph shape look better. Text is hyphenated according to the
current language options in place. By default, text is assumed to be in
English unless SILE is told otherwise. In the Latin text above, we turned
hyphenation off.

The final clever thing is that, where fonts declare ligatures (where two or more letters
are merged into one in order to make them visually more attractive), 
SILE automatically applies the ligature. So if you type \code{affluent
fishing} then, (depending on your font), your output might look like:
‘\examplefont{affluent fishing}.’ If you specifically
want to break up the ligature, then insert an empty group (using the grouping
characters \code{\{} and \code{\}}) in the middle of the ligature:
\code{af\{\}f\{\}luent f\{\}ishing}: \examplefont{af{}f{}luent f{}ishing}

\section{Commands}

Typically (and we’ll unpack that
statement later), SILE commands are made up of a backslash followed by a
command name, and a document starts with a \code{\\begin\{document\}} command 
and ends with \code{\\end\{document\}}.

A command may also take two other optional components: some \em{parameters}, and an \em{argument}. The \code{\\begin} command at the start of the document is an
example of this.\footnote{Strictly speaking \code{\\begin} isn’t actually a command
but we’ll pretend that it is for now and get to the details in a moment.} 

\begin{verbatim}
\line
\\begin[papersize=a4]\{document\}
\line
\end{verbatim}

The parameters to a command are enclosed in square brackets and take the form
\code{\em{key}=\em{value}};\break multiple parameters are separated by commas
or semicolons,
as in \code{[key1=value1,key2=value2,\dots]} Spaces around
the keys are not significant; we could equally write that as
\code{[key1 = value1; key2 = value2; \dots]}. The optional argument (of which
there can only be at most one) is enclosed in curly braces.\footnote{TeX users
may forget this and try adding a command argument “bare”, without the braces.
This won’t work; in SILE, the braces are mandatory.}

Here are a few more examples of SILE commands:

\begin{verbatim}
\line
\\eject                                     \% A command with no parameters or argument
 
\\font[family=Times,size=10pt]              \% Parameters, but no argument

\\chapter\{Introducing SILE\}                 \% Argument but no parameters
 
\\font[family=Times,size=10pt]\{Hi there!\}   \% Parameters and argument
\line
\end{verbatim}

\section{Environments}

Commands like \code{\\chapter} and \code{\\em} (emphasises text by
making it italic) are normally used to enclose a relatively small piece
of text; a few lines at most. Where you want to enclose a larger piece of
the document, you can use an \em{environment}; an environment begins
with \code{\\begin\{\em{name}\}} and encloses all the text up until the
corresponding \code{\\end\{\em{name}\}}. We’ve already seen an example,
the \code{document} environment, which must enclose the \em{entire} document.

Here is a secret: there is absolutely no difference between a command and
an environment. In other words, the following two forms are equivalent:

\begin{verbatim}
\line
\\font[family=Times,size=10pt]\{Hi there!\}
 
\\begin[family=Times,size=10pt]\{font\}
Hi there!
\\end\{font\}
\line
\end{verbatim}

However, in some cases the environment form of the command will be easier
to read and will help you to be clearer on where the command begins and ends.

\section{The XML Flavour}

While we’re on the subject of alternative forms, SILE can actually process its
input in a completely different file format. What we’ve seen so far has
been SILE’s “TeX-like flavor”, but if the first character of the 
input file is an angle bracket (\code{<}) then SILE will interpret its input
as an XML file. (If it isn’t well-formed XML, then SILE will get very upset.)

Any XML tags within the input file will then be regarded as SILE commands,
and tag attributes are interpreted as command parameters;
from then on, the two file formats are exactly equivalent, with one exception:
instead of a \code{<document>} tag, SILE documents can be enclosed in \em{any}
tag. (Although \code{<sile>} is conventional for SILE documents.)

In other words, the XML form of the above document would be:

\begin{verbatim}
\line
<sile papersize="a4">
Hello SILE!
</sile>
\line
\end{verbatim}

Commands without an argument need to be well-formed self-closing XML tags
(for instance, \code{<break/>}), and commands with parameters should have 
well-formed attributes. The example above, in XML flavor, would look like this:

\begin{verbatim}
\line
<font family="Times" size="10pt">Hi there!</font>
\line
\end{verbatim}

We don’t expect humans to write their documents in SILE’s XML flavor—the
TeX-like flavor is much better for that—but having an XML flavor allows for
computers to deal with SILE a lot more easily. One could create
graphical user interfaces to edit SILE documents, or convert other XML formats
to SILE.

However, there is an even smarter way of processing XML with SILE. For this,
you need to know that you can define your own SILE commands, which can range
from very simple formatting to fundamentally changing the way that SILE operates.
If you have a file in some particular XML format–let’s say it’s a DocBook file—and
you define SILE commands for each possible DocBook tag, then the DocBook file 
becomes a valid SILE input file, as-is.

In the final two chapters, we’ll provide
some examples of defining SILE commands and processing XML documents.

\chapter{Some Useful SILE Commands}

We’re going to organise our tour of SILE by usage; we’ll start by giving
you the most useful commands that you’ll need to get started typesetting
documents using SILE, and then we’ll gradually move into more and more
obscure corners as the documentation progresses.

\section{Fonts}

The most basic command for altering the look of the text is the \code{\\font}
command; it takes two forms:

\noindent{}• \code{\\font[\em{parameters\dots}]\{\em{argument}\}}

\noindent{}• \code{\\font[\em{parameters\dots}]}

The first form sets the given argument text in the specified font; the
second form changes the font used to typeset text from this point on.

So, for instance:

\begin{verbatim}
\line
Small text
 
\\font[size=15pt]%
Big text!
 
\\font[size=30pt]\{Bigger text\}
 
Still big text!
\line
\end{verbatim}

\noindent{}produces

\begin{examplefont}%
\line%
Small text

\noindent\font[size=15pt]%
Big text!

\noindent\font[size=30pt]{Bigger text}

\noindent{}Still big text!
\line
\end{examplefont}

\font[size=11pt]%

As you can see, one possible attribute is \code{size}, which can be specified as
a SILE \code{<dimension>}. A \code{<dimension>} is like a \code{<basic length>}
(described above) but with a few extra possible dimensions which are relative
to the size of the \em{current} font: ex units (\code{ex}), em units (\code{em}),
and en units (\code{en}).

The full list of attributes to the \code{\\font} command are:

\medskip

\noindent{}• \em{size}: as above.

\noindent{}• \em{family}: the name of the font to be selected. SILE should know
about all the fonts installed on your system, so that fonts can be specified by
their name. In the XML flavor of SILE, you can specify the font family as a
CSS-style ‘stack’ delimited by commas.

\noindent{}• \em{style}: can be \code{normal} or \code{italic}.

\noindent{}• \em{variant}: can be \code{normal} or \code{smallcaps}.

\noindent{}• \em{weight}: a CSS-style numeric weight ranging from \font[weight=100]{100},
through \font[weight=200]{200},
\font[weight=300]{300},
\font[weight=400]{400},
\font[weight=500]{500},
\font[weight=600]{600},
\font[weight=700]{700},
\font[weight=800]{800} to
\font[weight=900]{900}. Not all fonts will support all weights (many just have
two), but SILE will choose the closest.

\noindent{}• \em{language}: The two letter (ISO639-1) language code for the
text. This will affect both font shaping and hyphenation.

\medskip

It’s quite fiddly to be always changing font specifications manually; later
we’ll see some ways to automate the process. SILE provides the \code{\\em\{\dots\}}
command as a shortcut for \code{\\font[style=italic]\{\dots\}}. 
There is no shortcut for boldface, because boldface isn’t good typographic
practice and so we don’t want to make it easy for you to make bad books.

\section{Document Structure}

SILE provides a number of different \em{class}es of document (similar to
LaTeX classes). By default, you get the \em{plain} class, which has very
little support for structured documents. There is also the \em{book} class,
which adds support for right and left page masters, running headers, footnotes,
and chapter, section and subsection headings.

To use the commands in this section, you will need to request the \em{book}
class by specifying in your \code{\\begin\{document\}} command ‘\code{[class=book]}’;
for example, the document you are currently reading begins with the command
\code{\\begin[papersize=a4,class=book]\{document\}}.

\subsection{Chapters and Sections}

You can divide your document into different sections using the commands
\code{\\chapter\{\dots\}}, \code{\\section\{\dots\}} and \code{\\subsection\{\dots\}}.
The argument to each command is the name of the chapter or section respectively;
chapters will be opened on a new right-hand page, and the chapter name will form
the left running header. Additionally the section name and number will form the right running header. 

\note{Chapters, sections and subsections will be automatically
numbered starting from 1; to alter the numbering, see the documentation for the
\code{counters} package in the next chapter.}

This subsection begins with the command \code{\\subsection\{Chapters and Sections\}.}

\subsection{Footnotes}

Footnotes can be added to a book with the \code{\\footnote\{\dots\}} command.\footnote{Like this: \code{\\footnote\{Like this.\}}} The
argument to the command will be set as a footnote at the bottom of the page;
footnotes are automatically numbered from 1 at the start of each chapter.

\section{Indentation and Spacing}

Paragraphs in SILE normally begin with an indentation (by default, 20 points
in width). To turn this off, you can use the \code{\\noindent} command at the
start of a paragraph. (This current paragraph doesn’t need to call \code{\\noindent}
because \code{\\section} and \code{\\chapter} automatically call it for the
text following the heading.) A \code{\\noindent} can be cancelled by following
it with an \code{\\indent}.

To increase the vertical space between paragraphs or other elements, the commands \code{\\smallskip}, \code{\\medskip} and \code{\\bigskip} are available to add a 3pt, 6pt and 12pt
gap respectively. There will be a \code{\\bigskip} after this paragraph.

\bigskip

There are also some commands to increase the horizontal space in a line; from
the smallest to the largest, \code{\\thinspace} (1/6th of an em), \code{\\enspace}
(1 en), \code{\\quad} (1 em), and \code{\\qquad} (2em).

\begin{center}
You can center a paragraph of text by wrapping it in the \code{center} environment.
(\code{\\begin\{center\} \dots \\end\{center\}}). This paragraph is centered on the
page.
\end{center}

\section{Breaks}

SILE automatically determines line and page breaks; in later chapters we will
introduce some \em{settings} which can be used to tweak this process. However,
SILE’s plain class also provides some commands to help the process on its way.

Between paragraphs, the \code{\\break} command requests a \em{frame break} at the given location.
(The commands \code{\\framebreak} and \code{\\eject} are also available as synonyms.) Where there
are multiple frames on a page—for instance, in a document with multiple columns—the current frame will be ended and typesetting will recommence at the top of the next frame.
\code{\\pagebreak} (also known as \code{\\supereject}) is a more forceful variant,
and ensures that a new page is opened even if there are remaining frames on the page.
A less forceful variant is \code{\\goodbreak}, which suggests to SILE that this is
a good point to break a page. The opposite is \code{\\nobreak} which requests that, 
if at all possible, SILE does not break at the given point. A neutral variant is
\code{\\allowbreak}, which allows SILE to break at a point that it would otherwise
not consider as suitable for breaking.

\em{Within} a paragraph, these commands have a different meaning. The \code{\\break} command requests a \em{line} break at the given location, and, \em{mutatis mutandis},
so do \code{\\goodbreak}, \code{\\nobreak} and \code{\\allowbreak}. If you want to be 
absolutely sure that you are inhibiting a \em{page} break, you can say \code{\\novbreak}.

\raggedright
SILE normally fully-justifies text–that is, it tries to alter the spacing between
words so that the text stretches across the full width of the column. An alternative
to full justification is ragged right margin formatting, where the spacing between
words is constant but the right hand side of the paragraph may not line up. Ragged
right is often used for children’s books and for frames with narrow columns such as 
newspapers. To switch to ragged right formatting, use the
command \code{\\raggedright}. To switch back, use \code{\\justified}. This paragraph
is set ragged right.

\justified\set[parameter=document.lskip,value=0]
\section{Hyphenation and Language}

SILE hyphenates words based on its current language. (Language is set using the
\code{\\font} command above.) At present the only hyphenation patterns available for
SILE are for English and Greek, although it is not difficult for TeX users to 
produce additional pattern files. (Please send them to me if you do!)

SILE comes with a special “language” called \code{xx}, which has no hyphenation
patterns available. If you switch to this language, text will not be hyphenated.
The command \code{\\nohyphenation\{\dots\}} is provided as a shortcut for
\code{\\font[language=xx]\{\dots\}}.

\section{Including Other Files and Code}

To make it easier for you to author a large document, you can break your SILE document 
up into multiple files. For instance, you may wish to put each chapter into a
separate file; you may wish to develop a file of user-defined commands (see
chapter 6) and keep this separate from the main body of the document. You
will then need the ability to include one SILE file from another.

This ability is provided by the \code{\\include} command. It takes one mandatory
parameter, \code{src=\em{<path>}}, which represents the path to the file. So
for instance, you may wish to write a thesis like this:

\begin{verbatim}
\line
\\begin[papersize=a4,class=thesis]\{document\}
\\include[src=macros]
\\include[src=chap1]
\\include[src=chap2]
\\include[src=chap3]
\dots\par
\\include[src=endmatter]
\\end\{document\}
\line
\end{verbatim}

\code{\\include}s may be nested, in that file A can include file B which includes
file C.

SILE is written in the Lua programming language, and the Lua interpreter is
available at runtime. Just as one can run Javascript code from within a HTML
document using a \code{<script>} tag, one can run Lua code from within a SILE
document using a \code{\\script} command. (It looks better in XML-flavor.) This
command has two forms: \code{\\script[src=\em{<filename>}]} which includes a Lua
file, and \code{\\script\{\dots\}} which runs Lua code inline. 

Doing anything interesting inline requires knowledge of the internals of SILE,
(thankfully the code is not that hard to read)
but to get you started, the Lua function \code{SILE.typesetter:typeset(\dots)}
will add text to a page, \code{SILE.call("\dots")} will call a SILE command,
and \code{SILE.typesetter:leaveHmode()} ends the current paragraph and outputs the
text. So, for example:

\begin{verbatim}
\line
\\begin\{script\}
  for i=1,10 do
    SILE.typesetter:typeset(i .. " x " .. i .. " = " .. i*i .. ". ")
    SILE.typesetter:leaveHmode()
    SILE.call("smallskip")
  end
\\end\{script\}
\line
\end{verbatim}

produces the following output:

\begin{examplefont}
\line
\begin{script}
  SILE.call("indent");SILE.typesetter:leaveHmode()
  for i=1,10 do
    SILE.typesetter:typeset(i .. " x " .. i .. " = " .. i*i .. ". ")
    SILE.typesetter:leaveHmode()
    SILE.call("smallskip")
  end
\end{script}
\line
\end{examplefont}

\chapter{SILE Packages}

SILE comes with a number of packages which provide additional functionality.
In fact, the actual “core” of SILE’s functionality is very small and very
extensible, with most of the interesting features being provided by add-on
packages. SILE packages are written in the Lua programming language, and can
define new commands, change the way that the SILE system operates, or indeed
do anything that it’s possible to do in Lua.

As mentioned above, loading a package is done through the \code{\\script} command,
which runs Lua code. By convention packages live in the \code{packages/} subdirectory
of either your working directory or SILE’s installation directory. For instance,
we’ll soon be talking about the \code{grid} package, which normally can be found
as \code{/usr/local/lib/sile/packages/grid.lua}. To load this, we’d say:

\begin{verbatim}
\line
\\script[src=packages/grid]
\line
\end{verbatim}

\section{image}

As well as processing text, SILE can also include images.

\note{Image support is
rather rudimentary at present due to limitations of the libraries that SILE
uses.}

Loading the \code{image} package gives you the \code{\\img} command, fashioned
after the HTML equivalent. \code{\\img} takes the following parameters: 
\code{src=\dots} must be the path to an image file \em{in PNG format};
you may also give \code{height=\dots} and/or \code{width=\dots} parameters
to specify the output size of the image on the paper. If the size parameters
are not given, then the image will be output at its ‘natural’ pixel size.

Here is a 200x243 pixel image output with \code{\\img[src=documentation/gutenberg.png]}:\par
\img[src=documentation/gutenberg.png]

\raggedright
Here it is with (respectively) 
\code{\\img[src=documentation/gutenberg.png,width=120px]},\break 
\code{\\img[src=documentation/gutenberg.png,height=200px]}, and\break
\code{\\img[src=documentation/gutenberg.png,width=120px,height=200px]}:\par
\img[src=documentation/gutenberg.png,width=120px]
\img[src=documentation/gutenberg.png,height=200px]
\img[src=documentation/gutenberg.png,width=120px,height=200px]

\justified
Notice that images are typeset on the baseline of a line of text, rather like
a very big letter.

\section{rules}

The \code{rules} package draws lines. It provides two commands.

The first command is \code{\\hrule},
which draws a line of a given length and thickness, although it calls these
\code{width} and \code{height}. (A box is just a square line.)

Lines are treated just like other text to be output, and so can appear in the
middle of a paragraph, like this: \hrule[width=20pt, height=0.5pt] (that one
was generated with \code{\\hrule[width=20pt, height=0.5pt]}.)

Like images, rules are placed along the baseline of a line of text.

The second command provided by \code{rules} is \code{\\underline}, which
underlines its contents. 

\note{
Underlining is horrible typographic practice, and
you should \underline{never} do it.}

(That was produced with \code{\\underline\{never\}}.)

\section{color}

The \code{color} package allows you to temporarily change the color of the 
(virtual) ink that SILE uses to output text and rules. The package provides
a \code{\\color} command which takes one parameter, \code{color=\em{<color \nobreak{}specification>}}, and typesets
its argument in that color. The color specification is the same as HTML:
it can be a RGB color value in \code{#xxx} or \code{#xxxxxx} format, where \code{x}
represents a hexadecimal digit (\code{#000} is black, \code{#fff} is white,
\code{#f00} is red and so on), or it can be one of the HTML and CSS named colors.

\note{The HTML and CSS named colors can be found at \code{http://dev.w3.org/csswg/css-color/#named-colors}.}

So, for example, \color[color=red]{this text is typeset with \code{\\color[color=red]\{\dots\}}}.

Here is a rule typeset with \code{\\color[color=#22dd33]}:
\color[color=#ffdd33]{\hrule[width=120pt,height=0.5pt]}

\section{grid}
\grid[spacing=15pt]

In normal typesetting, SILE determines the spacing between lines of type
according to the following two rules:

\noindent• SILE tries to insert space between two successive lines so that their baselines
are separated by a fixed distance called the \code{baselineskip}.

\noindent• If this first rule would mean that the bottom and the top of the lines are less
than two points apart, then they are forced to be two points apart. (This distance
is configurable, and called the \code{lineskip})

The second rule is designed to avoid the situation where the first line has a long
descender (letters such as g, q, j, p, etc.) which abuts a high ascender on the second
line. (k, l, capitals, etc.)

In addition, the \code{baselineskip} contains a certain amount of ‘stretch’, so that
the lines can expand if this would help with producing a page break at an optimal
location, and similarly spacing between paragraphs can stretch or shrink.

The combination of all of these rules means that a line may begin at practically any
point on the page.

An alternative way of typesetting is to require that lines begin at fixed points on
a regular grid. Some people prefer the ‘color’ of pages produced by grid typesetting,
and the method is often used when typesetting on very thin paper as lining up the
lines of type on both sides of a page ensures that ink does not bleed through from
the back to the front. Compare the following examples: on the left, the lines are
guaranteed to fall in the same places on the recto (front) and the verso (back) of
the paper; on the right, no such guarantee is made.

\img[src=documentation/grid-1.png,height=130]
\img[src=documentation/grid-2.png,height=130]

The \code{grid} package alters the way that the SILE’s typesetter operates so that
the two rules above do not apply; lines are always aligned on a fixed grid, and
spaces between paragraphs etc. are adjusted to conform to the grid. Loading the package
adds two new commands to SILE: \code{\\grid[spacing=\em{<dimension>}]} and \code{\\no-grid}.
The first turns on grid typesetting for the remainder of the document; the second turns it off again.

At the start of this section, we issued the command \code{\\grid[spacing=15pt]} to
set up a regular 15-point grid. Here is some text typeset with the grid set up:

\smallskip
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
\smallskip

And here is the same text after we issue \code{\\no-grid}:

\no-grid\smallskip
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\section{verbatim}

The \code{verbatim} package is useful when quoting pieces of computer code and 
other text for which formatting is significant. It changes SILE’s settings
so that text is set ragged right, with no hyphenation, no indentation and
regular spacing. It tells SILE to honor multiple spaces, and sets a monospaced
font.

\note{Despite the name, \code{verbatim} does not alter the way that SILE
sees special characters. You still need to escape backslashes and braces:
to produce a backslash, you need to write \code{\\\\}.}

Here is some text set in the verbatim environment:

\begin{verbatim}
function SILE.repl()
  if not SILE._repl then SILE.initRepl() end
  SILE._repl:run()
end
\end{verbatim}

\eject\section{Packages usually used by other packages}

In addition, there are certain packages that you \em{probably} don’t need
to use directly, as their main job is to provide more
basic functionality to other packages and classes. Classes such as the 
\code{book} class compose functionality from different auxiliary packages.

\subsection{footnotes}

For instance, we’ve seen that the \code{book} class allows you to add
footnotes to text with the \code{\\footnote} command. This command is
actually provided by the \code{footnotes} package. The \code{book}
class loads up the package and tells it where to put the footnotes
that are typeset, and the \code{footnotes} package takes care of
formatting the footnotes. It does this by using a number of other
packages that we will describe below.

\subsection{counters}

Various parts of SILE such as the \code{footnotes} package and the
sectioning commands keep a counter of things going on: the current 
footnote number, the chapter number, and so on. The counters package
allows you to set up, increment and typeset named counters. It
provides the following commands:

• \code{\\set-counter[id=\em{<counter-name>},value=\em{<value}]} – sets
the counter called \code{<counter-name>} to the value given. 

• \code{\\increment-counter[id=\em{<counter-name>}]} – does the
same as \code{\\set-counter} except that when no \code{value} parameter
is given, the counter is incremented by one.

• \code{\\show-counter[id=\em{<counter-name>}]} – this typesets the
value of the counter according to the counter’s declared display type.

\note{All of the commands in the counters package take an optional
\code{display=\em{<display-type>}} parameter
to set the \em{display type} of the counter. 

The available display types are: \code{arabic}, the default;
\code{roman}, for lower-case Roman numerals; and \code{Roman} for upper-case
Roman numerals.}

So, for example, the following SILE code:

\begin{verbatim}
\line
\\set-counter[id=mycounter, value=2]
\\show-counter[id=mycounter]

\\increment-counter[id=mycounter]
\\show-counter[id=mycounter, display=roman]
\line
\end{verbatim}

produces: 

\line
\examplefont{2

\noindent{}iii}
\line

\subsection{raiselower}

If you don’t want your images, rules or text to be placed along
the baseline, you can use the \code{raiselower} package to move them up
and down. (The \code{footnote} package uses this to superscript the
footnote reference numbers.)

It provides two simple commands, \code{\\raise} and \code{\\lower} which
both take a \code{height=\em{<dimension>}} parameter. They will respectively
raise or lower their argument by the given height. The raised or lowered
content will not alter the height or depth of the line.

Here is some text raised by \raise[height=3pt]{three points}; here is
some text lowered by \lower[height=4pt]{four points}.

The previous paragraph was generated by:

\begin{verbatim}
Here is some text raised by \\raise[height=3pt]\{three points\}; here is
some text lowered by \\lower[height=4pt]\{four points\}.
\end{verbatim}

\subsection{frametricks}

As we mentioned in the first chapter, SILE uses frames as an indication
of where to put text onto the page. The \code{frametricks} package assists
package authors by providing a number of commands to manipulate frames.

The most immediately useful is \code{\\showframe}. This asks the output
engine to draw a box and label around a particular frame. It takes an optional
parameter \code{id=\em{<frame id>}}; if this is not supplied, the current
frame is used. If the ID is \code{all}, then all frames declared by the
current class are displayed.

\breakframevertical\par
The command \code{\\breakframevertical} breaks the current frame in two
at the specified location into an upper and lower frame. If the frame initially had the ID
\code{main}, then \code{main} becomes the upper frame (before the command)
and the lower frame (after the command) is called \code{main_}. We just
issued a \code{\\breakframehorizontal} command at the start of this paragraph,
and now we will issue the command \code{\\showframe}. \showframe As you can
see, the current frame is called
\code{\script{SILE.typesetter:typeset(SILE.typesetter.frame.id)}}
and now begins at the start of the paragraph.

Similarly, the \code{\\breakframehorizontal} command breaks the frame in two
into a left and a right frame.
The command takes an optional argument \code{offset=<dimension>}, specifying
where on the line the frame should be split. If it is not supplied, the 
frame is split at the current position in the line.

The command \code{\\shiftframeedge} allows you to reposition the current
frame left or right. It takes \code{left=} and/or \code{right=} parameters,
which can be positive or negative dimensions. It should only be used at the
top of a frame, as it reinitializes the typesetter object.

\bigskip
\float[bottomboundary=5pt]{\font[size=60pt]{C}}ombining all of these commands, the \code{\\float}
command breaks the current frame, creates a small frame to hold a floating
object (like the dropcap at the start of this sentence), flows text into
the surrounding frame, and then, once text has descended past the floating object,
moves the frame back into place again. It takes two optional parameters, \code{bottomboundary=\em{<dimension>}} and/or \code{rightboundary=\em{<dimension>}}, which
open up additional space around the frame. At the start of this paragraph, I issued
the command \code{\\float[bottomboundary=5pt]\{\\font[size=60pt]\{C\}\}}.

\break
\subsection{insertions}

The \code{footnotes} package works by taking auxiliary material (the
footnote content), shrinking the current frame and inserting it into the
footnote frame. This is powered by the \code{insertions} package; it doesn’t
provide any user-visible SILE commands, but provides Lua functionality to
other packages. TeX wizards may be interested to realise that insertions are
implemented by an external add-on package, rather than being part of the SILE core.

\subsection{twoside}

The \code{book} class described in chapter 4 sets up left and right mirrored
page masters; the \code{twoside} package is responsible for swapping between
the two left and right frames, running headers and so on. It has no user-serviceable
parts.

\subsection{infonode}

\note{This package is only for class designers.}

While typesetting a document, SILE first breaks a paragraph into lines, then
arranges lines into a page, and later outputs the page. In other words,
while it is looking at the text of a paragraph, it is not clear what page
the text will eventually end up on. This makes it difficult to produce
indexes, tables of contents and so on where one needs to know the page number 
for a particular element.

To get around this problem, the \code{infonode} allows you to insert \em{information
nodes} into the text stream; when a page is outputted, these nodes are collected into
a list, and a class’s output routine can examine this list to determine which nodes
fell on a particular page. \code{infonode} provides the \code{\\info} command
to put an information node into the text stream; it has two required parameters,
\code{category=} and \code{value=}. Categories are used to group similar sets of
node together.

As an example, when typesetting a Bible, you may wish to display which range
of verses are on each page as a running header. During the command which starts
a new verse, you would insert an information node with the verse reference:

\begin{verbatim}
\line
SILE.Commands["info"]({ category = "references", value = ref }, {})
\line
\end{verbatim}

During the \code{endPage} method which is called at the end of every page,
we look at the list of “references” information nodes: 

\begin{verbatim}
\line
local refs = SILE.scratch.info.thispage.references
local runningHead = SILE.shaper.shape(refs[1] .. " - " .. refs[#refs])
SILE.typesetNaturally(rhFrame, runningHead);
\line
\end{verbatim}

\chapter{SILE Macros and Commands}

\noindent One of the reasons that we use computers is that they are
very good at doing repetitive jobs for us, so that we don’t have to.
Perhaps the most important skill in operating computers, and particularly
in programming computers, is noticing areas where an action is being
repeated, and allowing the computer to do the work instead of the human.
In other words, Don‘t Repeat Yourself.

The same is true in operating SILE. After you have been using the
system for a while, you will discover that there are patterns of input
that you need to keep entering again and again.

\section{A simple macro}

\define[command=SILE]{S\lower[height=0.5ex]{I}L\glue[width=-.2em]\raise[height=0.6ex]{\font[size=0.8em]{E}}}
For instance, let’s suppose that we want to design a nice little
“bumpy road” logo for SILE. (Afficionados of T\glue[width=-.1667em]\lower[height=0.5ex]{E}\glue[width=-.125em]X and friends will be familar with the concept of
bumpy road logos.) Our logo will look like this: \SILE. It’s not a great
logo, but we’ll use it as \SILE’s logo for the purposes of this section.

To typeset
this logo, we need to ask \SILE to: typeset an ‘S’; typeset an ‘I’ lowered by
a certain amount (half an ex, as it happens); typeset an ‘L’; walk backwards
along the line a tiny bit; typeset a smaller-sized ‘E’ raised by a certain amount.

In \SILE code, that looks like:

\begin{verbatim}
\line
S\\lower[height=0.5ex]\{I\}L\\glue[width=-.2em]\\raise[height=0.6ex]\{\\font[size=0.8em]\{E\}\} 
\line
\end{verbatim}

(Don‘t worry about the \code{\\glue} command for the moment; we’ll come back
to that later.)

We’ve used our logo four times already in this chapter, and we don‘t want to
have to input that whole monostrosity each time we do so. What we would like
to do is tell the computer “this is \SILE’s logo; each time I enter \code{\\SILE},
I want you to interpret that as \code{S\\lower[height=0.5ex]\{I\}L\\glue[width=-.2em]\\raise[height=0.6ex]\{\\font[size=0.8em]\{E\}\}}”.

In other words, we want to define our own commands.

SILE\footnote{Let’s give up on the logo at this point.} allows you to define
your own commands in two ways. The simplest commands of all are those like 
\code{\\SILE} above: “when I write \code{\\x}, I 
want SILE to pretend that I had written \code{X \\Y Z} instead.” These are
called \em{macros}, and the process of pretending is called \em{macro expansion}.

You can define these kinds of macros within a SILE file itself. In this
very file, we entered:

\begin{verbatim}
\line
\\define[command=SILE]\{
S\\lower[height=0.5ex]\{I\}L\\glue[width=-.2em]\\raise[height=0.6ex]\{\\font[size=0.8em]\{E\}\}
\}
\line
\end{verbatim}

We're using the built-in SILE command \code{\\define}. \code{\\define} takes
an option called \code{command}; its value is the name of the command we
are defining. The content of the \code{\\define} command is a series of SILE instructions to
be executed when the command is used.

\begin{note}
At this point it’s worth knowing the precise rules for allowable 
names of SILE commands. 

Commands in XML-flavor input files must be allowable XML tag names or else your
input files will not be well formed. Command names in TeX-flavor input files 
may consist of any number of alphanumeric characters, hyphens or colons.
Additionally, any single character is a valid TeX-flavor command name. (Hence
\code{\\\\} for typesetting a backslash.)

When it comes to defining commands, commands defined by an XML-flavor file can actually have
any name that you like–even if they are not accessible from XML-favour! (You may define oddly-named commands in a XML-flavor SILE file
and then use them in a TeX-flavor SILE file.) Commands defined in TeX-flavor
obviously have to have names which are valid parameter values, or else they will
not parse correctly either; parameter values happen to consist
of any text up until the nearest comma, semicolon or closing square bracket.
\end{note}

\section{Macro with content}

Now let’s move on to the next level; sometimes you will want to create
commands which are not simply replacements, but which have arguments of their
own. As an example, let’s say we use the \code{color} package to turn a bit of
text red \color[color=red]{like this}. The usual way to do that is to say

\begin{verbatim}
\line
\\color[color=red]\{like this\}
\line
\end{verbatim}

However, we‘re not always going to want to be highlighting the words ‘\code{like this}’.
We might want to be able to highlight other text instead. We need the ability
to wrap the command \code{\\color[color=red]\{ ... \}} around our chosen content.
In other words, we want to be able to define our own commands which take arguments.

The way we express this in SILE is with the \code{\\process} command. \code{\\process}
is only valid within the context of a \code{\\define} command (you’ll mess everything
up if you try using it somewhere else), and it
basically means ‘do whatever you were planning to do with the arguments to this
command.’ So if we want to a command which makes things red, we can say:

\begin{verbatim}
\line
\\define[command=red]\{\\color[color=red]\{\\process\}\}

…

Making things red is a \\red\{silly\} way to emphasise text.
\line
\end{verbatim}

\begin{note}
You can’t call \code{\\process} more than once within the same macro.

In the definition of the \code{\\chapter} command, we want to 1) display the
chapter name in a big bold font, and 2) use the chapter name as the left
running header. If you try writing the \code{\\chapter} command as a macro,
you will get stuck—once you’ve \code{\\process}ed the chapter name to display
it in bold, you won’t be able to process it again to set the running header.

So the \code{\\chapter} command cannot be written as a simple macro. The other
way to implement your own commands is to write them in the Lua programming
language, which is what happens for \code{\\chapter}. We will see how to do
this in later chapters.

The \code{\\define} command really is meant to be used just for simple things.
\end{note}

\section{Nesting macros}

That said, one thing you can do is to call a macro within a macro. This should
be obvious, because a macro is just a replacement for the current processing
step—when SILE reads a macro command, it behaves as if you had entered the 
definition of the macro instead, and of course such a definition can contain
other commands.

So it is possible even within the simple scope of macro processing to achieve
quite a lot of automation.

For instance, within this book, there have been a number of notes—italicized
paragraphs between two heavy lines with a left margin. These have been typeset
with the \code{\\note} command; this is not a built-in command but a macro
specified within the \code{documentation/macros.sil} file included by this document.
Here is one way to define \code{\\note}, in XML flavour:

\begin{verbatim}
\line
<define command="line">
  <par/><smallskip/><noindent/>
  <hrule width="450pt" height="0.3pt"/><par/>
  <novbreak/><smallskip/><novbreak/>
</define>

<define command="narrower">
  <set parameter="document.lskip" value="24pt"/>
  <process>
  <set parameter="document.lskip" value="0pt"/>
</end>

<define command="notefont"><font style="italic" size="10pt"><process/></font></notefont>

<define command="note">
  <narrower>
    <line/>
    <notefont><process/></notefont>
    <line/>
  </narrower>
</define>
\line
\end{verbatim}

The only command we have not yet met here is \code{\\set}, which we will now
investigate.

\chapter{SILE Settings}

As well as commands, SILE offers a variety of knobs and levers which affect
how it does its job. Changing these parameters can have anything from a 
subtle to a dramatic effect on the eventual document. External packages may
declare their own settings (although none of the packages which ship with
SILE happen to do so), but here we will run through the settings which are
built into the SILE system itself.

Settings in SILE are \em{namespaced} so that 1) the name of the setting gives you
some kind of clue as to what area of the system it will affect, and 2) packages
can define their own settings without worrying that they will be interfering
with other packages or the SILE internals. Namespacing of settings takes the
form \code{\em{area.name}}–so for instance, \code{typesetter.orphanpenalty} is
the setting which changes how the typesetter penalizes orphan (end-of-paragraph)
lines.

The interface to changing settings from within a SILE document is the
\code{\\set} commmand. It take two options: a \em{parameter} option which
expresses which setting is being changed, and a \em{value} option which expresses
the value to which the setting is being changed. As an example:

\begin{verbatim}
\line
\\set[parameter=typesetter.orphanpenalty, value=250]
\line
\end{verbatim}

Now, let’s begin looking at what each of the built-in settings does, starting
from the most obvious and moving towards the most subtle.

\section{Spacing Settings}

In our \code{\\note} example, we saw the setting \code{document.lskip}.
This is a \em{glue} parameter which is added to the left side of every line.
Setting this to a positive length effectively increases the left margin of
the text. Similarly, \code{document.rskip} adds some space to the right side of
every line.

\begin{note}
\notehead{Glue} A \em{glue} parameter is slightly different from an ordinary dimensioned length. Glue basically means ‘space,’ but as well as signifying a length,
it also has two additional optional components: \em{stretch} and \em{skip},
specified as \code{<dimension> plus <dimension> minus <dimension>}. The
first dimension is the basic length; the stretch is the maximum length that
can be added to it, and the shrink is some length that can be taken away from it.
For instance, \code{12pt plus 3pt minus 6pt} specifies a space that would
ideally by 12 points, but can expand or contract from a minimum of 9 points to a maximum
of 18 points.
\end{note}

\break
So, for instance, to center a paragraph, you can set the margin parameters like
so:
\begin{verbatim}
\line
\\set[parameter=document.lskip,value=20pt plus 1000pt]\% or similar ridiculous quantity
\\set[parameter=document.rskip,value=20pt plus 1000pt]
\line
\end{verbatim}
\par

\noindent%
\set[parameter=document.lskip,value=20pt plus 1000pt]%
\set[parameter=document.rskip,value=20pt plus 1000pt]%
This will narrow the left and right margins of the paragraph by at least
20 points, but adds a large stretch which will be evenly distributed on both
the left and right side of each line, leaving the text of the paragraph sitting 
in the middle.\par

\medskip
\set[parameter=document.lskip,value=0pt]%
\set[parameter=document.rskip,value=0pt]%
The indentation at the start of each paragraph is controlled by the 
setting \code{document.parindent}; this is a glue parameter, and by default it’s 
set to 20pt with no stretch and shrink. Actually, the amount added to the
start of the paragraph is \code{current.parindent}. After each paragraph,
\code{current.parident} is reset to the value of \code{document.parindent}. The 
\code{\\noindent} command works by setting \code{current.parindent} to zero.

\medskip%
\set[parameter=current.parindent,value=-20pt]%
\set[parameter=document.lskip,value=20pt]%
How would you make a paragraph like this with a ‘hanging’ indentation? We’ve
set the \code{document.lskip} to 20 points, and the \code{current.parindent} to
\em{minus} 20 points. (In other words, we called:\break\code{\\set[parameter=document.lskip,value=20pt]} and \code{\\set[parameter=current.parindent,\break{}value=-20pt]}.)

\medskip%
\set[parameter=document.lskip,value=0pt]%
The space between \em{paragraphs} is set with the glue parameter
\code{document.parskip}. It’s normally set to five points with one point of stretchability.

As we mentioned in the section on grid typesetting, the rules for spacing between 
\em{lines} within a paragraph is determined by two
rules. Let’s reiterate those rules now in terms of settings:

\noindent• SILE tries to insert space between two successive lines to make their 
baselines exactly \code{document.baselineskip} apart.

\noindent• If this first rule would mean that the bottom and the top of the lines are less
than \code{document.lineskip} apart, then they are forced to be \code{document.lineskip} apart.

The final spacing setting is \code{document.spaceskip}. Normally the size of
the space between \em{words} is determined by the width of the space character
in the current font. If you want to set it explicitly, you can set the 
\code{document.spaceskip} setting. If you want to go back to the default (measuring
the space character of the font), then you need to \em{unset} the setting. To
unset it, just call \code{\\set} with no \code{value} parameter:
\code{\\set[parameter=document.spaceskip]}.

\section{Typesetter settings}

The settings which affect SILE’s spacing controls have the most obvious effect
on a document; the typesetter itself has some knobs that can be twiddled:

\code{typesetter.widowpenalty} and \code{typesetter.orphanpenalty}\footnote{TeX
users, please notice the renaming.} affect how strongly SILE is averse to 
leaving stray lines at the start and end of pages. A \em{widow} happens when
a page is broken leaving one line at the bottom of a page; an \em{orphan} line
is the last line in a paragraph broken off at the top of the page. By default,
the \em{penalty} attached to breaking the page at one of these places is 150
penalty points. This value can be any number up to \code{10000}, which means
“never break at this point.”

\set[parameter=typesetter.parfillskip,value=0pt]
SILE automatically inserts a piece of massively stretchable
glue at the end of each paragraph; without this, the justification algorithm
would apply justification to the entire paragraph, including the last fine,
and produce a fully justified paragraph. (Normally we want the last line of a justified paragraph to be 
left-aligned.)
The size of this glue is defined in the setting
\code{typesetter.parfillskip}. Its default value is \code{0pt plus 10000pt} but
for this current paragraph, we have unset it.

\set[parameter=typesetter.parfillskip,value=0pt plus 10000pt]
Finally, the typesetter needs to know what separates a paragraph. Normally,
this is two consecutive newlines in the input. However, when you are dealing with
transforming XML input, this may not be a good assumption; in that case, you
can set the setting \code{typesetter.parseppattern} to a Lua pattern. Its
default setting is \code{\\n\\n+}. Additionally, the way that multiple spaces
in an input are collapsed into one space is by means of the \code{shaper.spacepattern}
setting. By default, this is set to \code{\%s+} (any number of spaces are interpreted
as one space.) If you want to preserve spacing, so that two spaces in the input
are typeset as two spaces in the output, you can set the space pattern to \code{\%s}.

\section{Linebreaking settings}

SILE’s linebreaking algorithm is lifted entirely from TeX, and so maintains the
same level of customizability as TeX. Here is a quick run-down of the settings
applicable to the line-breaking algorithm. You are expected to know what you
are doing with these.

\noindent• \code{linebreak.tolerance}: How bad a breakpoint is before it is rejected
by the algorithm. (Default: 500)

\noindent• \code{linebreak.pretolerance}: If there are no breakpoints better than
this, the paragraph is considered for hyphenation. (Default: 100)

\noindent• \code{linebreak.adjdemerits}: Additional demerits which are accumulated in the course of paragraph building when two consecutive lines are visually incompatible. In these cases, one line is built with much space for justification, and the other one with little space. (Default: 10000)

\noindent• \code{linebreak.looseness}: How many lines the current paragraph should
be made longer than normal. (Default: 0)

\noindent• \code{linebreak.prevGraf}: The number of lines in the paragraph last added to the vertical list.

\noindent• \code{linebreak.emergencyStretch}: Assumed extra stretchability in lines of a paragraph. (Default: 0)

\noindent• \code{linebreak.linePenalty}: Penalty value associated with each line break. (Default: 10)

\noindent• \code{linebreak.hyphenPenalty}: Penalty associated with break at a hyphen. (Default: 50)

\noindent• \code{linebreak.doubleHyphenDemerits}: Penalty for consecutive lines ending with a hyphen. (Default: 10000)

\section{Settings from Lua}

Most of the time you will not be fiddling with these settings at the SILE layer,
because complex layout commands are expected to be implemented in Lua. The
following SILE functions access the settings system from inside Lua:

\noindent• \code{SILE.settings.set(\em{<parameter>}, \em{value})}: sets a setting.

\note{
You should note that, while in the SILE layer, the \code{\\set} command does its
best to turn the textual description of a type into the appropriate Lua type
for the value. \code{SILE.settings.set} does not do that; it expects the value
to be of the appropriate type: lengths need to be a \code{SILE.Length} object,
glue must be \code{Glue} and so on.}

\noindent• \code{SILE.settings.get(\em{<parameter>})}: retrieves the current
setting of the parameter.

\noindent• \code{SILE.settings.temporarily(\em{function})}: Saves all settings,
runs the function and then restores all settings afterwards.

\noindent• \code{SILE.settings.declare(\em{<specification>})}: Declares a new
setting. See the base settings in \code{settings.lua} for examples of how to
call this. A class or package should namespace its settings with \code{<package>.<setting>}.

\chapter{The Nitty Gritty}

\noindent{}We are finally at the bottom of our delve into SILE‘s commands
and settings. Here are the basic building blocks out of which all of the
other operations in SILE are created; in fact, they are the basic
building blocks of SILE's operation.

\note{At this point, it is expected that
you are a class designer, and will be able to follow the details of how
SILE implements these commands and features; we will also explain how to
interact with these components at the Lua level.}

\section{Boxes, Glue and Penalties}

SILE‘s job is, looking at it in very abstract terms, all about arranging
little boxes on a page. Some of those boxes have letters in them, and are
those letters are such-and-such a number of points wide and 
such-and-such a number of points high; 
some of the boxes are empty but are there just to take up space; when a
horizontal row of boxes has been decided (i.e. when a line break is determined)
then the whole row of boxes is put into another box and the vertical list
of boxes are then arranged to form a page.

Conceptually, then, SILE knows about a few different basic components: 
horizontal boxes (such as a letter); horizontal glue (the stretchable, shrinkable
space between words); vertical boxes (a line of text); vertical glue (the space
between lines and paragraphs); and penalties (information about when and when
not to break lines and pages).\footnote{Additionally there are two more types of box
that SILE cares about: N-nodes and discretionaries.}

The most immediately useful of these are horizontal and vertical glue. It
is possible to explicitly add horizontal and vertical glue into SILE‘s processing
stream using the \code{\\glue} and \code{\\skip} commands. These take a
\code{width} and a \code{height} parameter respectively, both of which are
glue dimensions. So, for instance, the \code{\\smallskip} command is 
the equivalent of \code{\\skip[height=3pt plus 1pt minus 1pt]}; \code{\\thinspace}
is defined as being \code{\\glue[width=0.16667em]}.

Similarly, there is a \code{\\penalty} command for inserting penalty nodes;
\code{\\break} is defined as \code{\\penalty[penalty=-10000]} and \code{\\nobreak}
is \code{\\penalty[penalty=10000]}.

You can also create horizontal and vertical boxes from within SILE. One obvious
reason for doing so would be to explicitly avoid material being broken up by a
page or line break; another reason for doing so would be that once you box some
material up, you then know how wide or tall it is. The \code{\\hbox} and \code{\\vbox}
commands put their contents into a box; when called from Lua, they also \em{return}
the new box.

\subsection{From Lua}

SILE’s Lua interface contains a \code{nodefactory} for creating boxes and glue.
Before we get into that, however, you need to know that glue measurements in SILE
should always be specified in terms of \code{SILE.length} objects; these are 
“three-dimensional” lengths, in that they consist of a base length plus stretch and
shrink. To construct a \code{SILE.length}:

\begin{verbatim}
\line
local l = SILE.length.new(\{ length = x, stretch = y, shrink = z\})
\line
\end{verbatim}

Now we can construct horizontal and vertical glue:

\begin{verbatim}
\line
local glue  = SILE.nodefactory.newGlue (\{ width =  l\})
local vglue = SILE.nodefactory.newVglue(\{ height = l\})
\line
\end{verbatim}

SILE’s typesetting is organised by the \code{SILE.typesetter} object; it maintains
two queues of material that it is working on–the node queues (\code{SILE.typesetter.state.nodes}) contains new horizontal boxes and glue that are going to be broken up into lines soon; and the output queue (\code{SILE.typesetter.state.outputQueue}) which consists
of vertical material (lines) which are going to be broken up into pages. Line breaking
and page breaking happens when the typesetter moves between horizontal and vertical
mode; you can force this to happen by calling the function \code{SILE.typesetter:leaveHmode()}.
The SILE-level command for forcing a paragraph end is \code{\\par}.

So, if you want to manually add a vertical space to the output, first ensure that material in the current paragraph
has been all properly boxed-up and moved onto the output queue
by calling
\code{SILE.typesetter:leaveHmode()}; then add your
desired glue to the output queue.

Adding boxes and glue to the typesetter’s queues is
such a common operation that the typesetter has some utility methods to construct
the nodes and add them for you:

\begin{verbatim}
\line
SILE.typesetter:leaveHmode()
SILE.typesetter:pushVglue(\{ height = l \})
\line
\end{verbatim}

Adding boxes yourself is a little more complicated, because boxes need to
know how to display themselves on the page. To facilitate this, they normally
store a \code{value} and an \code{outputYourself} member function. For instance,
the \code{image} package actually does something very simple; it adds a horizontal
box to the node queue which knows the width and height of the image, the source,
and instructions to the output engine to display the image:

\begin{verbatim}
\line
SILE.typesetter:pushHbox(\{ 
  width= \dots,
  height= \dots,
  depth= 0,
  value= options.src,
  outputYourself= function (this, typesetter, line)
    SILE.outputter.drawPNG(this.value, 
      typesetter.frame.state.cursorX, typesetter.frame.state.cursorY-this.height, 
      this.width,this.height
    );
    typesetter.frame:moveX(this.width)
end\});
\line
\end{verbatim}

Adding horizontal and vertical penalties to the typesetter’s queues is similarly 
done with the \code{SILE.typesetter:pushPenalty(\{penalty = x\})} and 
\code{SILE.typesetter:pushVpenalty(\{penalty = y\})} methods.

\section{Frames}

As we have previously mentioned, SILE arranges text into frames on the page. 
Normally those frames are defined by your document class, but you can actually
create your own frames on a per-page basis using the \code{\\pagetemplate}
and \code{\\frame} commands. There are very few situations in which you will
actually want to do this, but if you can understand this, it will help you
to understand how to define your own document classes.

For instance, in a couple of pages time we’re going to implement a two-column layout.
SILE uses a \em{constraint solver} system to declare its frames, which means
that you can tell it how the frames relate to each other and it will compute
where the frames should be physically placed on the page.

Here is how we will go about it. We need to start with a page break, because
SILE will not appreciate you changing the page layout after it’s started to
determine how to put text onto that page.\footnote{Of course you can use
the \code{frametricks} package to get around this limitation—split the current
frame and start fiddling around with the positions of the new frames that
\code{frametricks} created for you.} How do we get to the start of a new
page? Remember that the \code{\\eject} (another word for \code{\\break} in
vertical mode) only adds a penalty to the end of the output queue; page breaking
is triggered when we leave horizontal mode, and the way to do that is \code{\\par}.
So we start with \code{\\eject\\par} and then we will begin a \code{\\pagetemplate}.
Within \code{\\pagetemplate} we need to tell SILE which frame to being typesetting
onto.

\begin{verbatim}
\line
\\eject\\par
\\begin[first-content-frame=leftCol]\{pagetemplate\}
\line
\end{verbatim}

Now we will declare our columns. But we’re actually going to start by declaring
the gutter first, because that’s something that we know and can define; we’re
going to stipulate that the gutter width will be 3\% of the page width:

\begin{verbatim}
\line
\\frame[id=gutter,width=3\%]
\line
\end{verbatim}

\begin{note}%
Declarations of frame dimensions are like ordinary SILE \code{<dimension>}s,
except with three additional features:

\noindent• You can refer to properties of other frames using the \code{top()},
\code{bottom()}, \code{left()}, \code{right()}, \code{height()} and \code{width()}
functions. These functions take a frame ID. SILE magically pre-defines the frame
\code{page} to allow you to access the dimensions of the whole page.

\noindent• You can use arithmetic functions: plus, minus, divide, multiply and
brackets have their ordinary arithmetic meaning. To declare that frame \code{b} 
should be half the height of frame \code{a} plus 5 millimeters, you can say
\code{height=5mm + (height(b) / 2)}. However as we will see later it is usually
better to structure your declarations to let SILE make those kind of computations for
you.

\noindent• Since book design is often specified in terms of proportion of a page,
you can use the shortcut \code{width=5\%} instead of \code{width=0.05 * width(page)}
and \code{height=50\%} instead of \code{height=0.5 * height(page)}. SILE knows
whether you’re dealing with vertical or horizontal percentages.

\end{note}

Next we declare the left and right column frames. The \code{book} class
gives us some frames already, one of which, \code{r}, is a standard right-hand page.
We will use the boundaries of this frame to declare our columns: the left
margin of the left column is the left margin of the textblock; the right margin of
the right column is the right margin of the textblock. But we also want
a few other parameters to ensure that:

\noindent• the gutter is placed between our two columns

\noindent• the two columns have the same width (We don’t know what that width is, but SILE
will work it out for us.)

\noindent• after the left column is full, typesetting should move to the right
column.

\begin{verbatim}
\line
\\frame[id=leftCol, left=left(r), right=left(gutter),
       top=top(r), bottom=bottom(r), 
       next=rightCol]
\\frame[id=rightCol, left=right(gutter), right=right(r),
       top=top(r), bottom=bottom(r),
       width=width(leftCol)]
\line
\end{verbatim}

And now finally we can end our \code{pagetemplate}.

\begin{verbatim}
\line
\\end\{pagetemplate\}
\line
\end{verbatim}

Let’s do it.
\eject\par%
\begin[first-content-frame=leftCol]{pagetemplate}
\frame[id=gutter,width=3%]
\frame[id=leftCol,left=left(r),right=left(gutter),top=top(r),bottom=bottom(r),next=rightCol]
\frame[id=rightCol,left=right(gutter),right=right(lRH),top=top(r),bottom=bottom(r),width=width(leftCol)]
% Actually we will also redefine the l frame because YANETUT.
\frame[id=l,left=left(r),right=right(r),top=top(r),bottom=bottom(r)]
\end{pagetemplate}
\showframe[id=leftCol]\showframe[id=rightCol]

So there we have it: a two-column page layout.

In the next chapter we’ll use the knowledge of how to declare frames to
help us to create our own document class files. In the meantime, here is
some dummy text to demonstrate the fact that text does indeed flow between
the two columns naturally:

\lorem[words=500]

\chapter{Designing Basic Class Files}

Now we know how to define a frame layout for a single page, let’s try
to define one for an entire document.

Document classes are Lua files, and live somewhere in the \code{classes/}
subdirectory of either your current directory or your SILE path (typically
\code{/usr/local/share/sile}). We’re going to create a simple class file
which merely changes the size of the margins and the textblock. We’ll call
it \code{bringhurst.lua}, because it replicates the layout of the Hartley
& Marks edition of Robert Bringhurst’s \em{The Elements of Typographical Style}.

We are designing a book-like class, and so we will inherit from SILE’s
standard \code{book} class, \code{classes/book.lua}.

Let’s briefly have a look at \code{book.lua} to see how it works;
after the initial class definition, we see  the following frame declarations: 
(wrapped for legibility)

\begin{verbatim}
\line
book:declareFrame("r",    \{left = "8.3\%",
                            right = "86\%",
                            top = "11.6\%",
                            bottom = "top(footnotes)"
                          \});
book:declareFrame("folio",\{left = "left(r)",
                            right = "right(r)",
                            top = "bottom(footnotes)+3\%",
                            bottom = "bottom(footnotes)+5\%" 
                          \});
book:declareFrame("rRH",  \{left = "left(r)",
                            right = "right(r)",
                            top = "top(r) - 8\%",
                            bottom = "top(r)-3\%"
                          \});
book:declareFrame("footnotes", \{ left="left(r)", 
                            right = "right(r)",
                            height = "0",
                            bottom="83.3\%"
                          \});
\line
\end{verbatim}

So there are four frames directly declared; the first is the 
right-hand master frame, which by SILE convention is called
\code{r}. Directly abutting the \code{r} frame at the bottom is
the \code{footnotes} frame. The top of the textblock
and the bottom of the footnote frame have fixed positions, but the
boundary between textblock and footnote is variable. Initially
the height of the footnotes is zero (and so the textblock takes up
the full height of the page) but as footnotes are inserted
into the footnote frame, its height will be adjusted; its bottom
is fixed and therefore its top will be adjusted, and the bottom
of the main textblock frame will also be correspondingly adjusted.

The folio frame (the page number) lives below the footnotes, and the
running headers live above the \code{r} frame.

Next, we use the \code{twoside} package to mirror our right-page
frames into left-page frames:

\begin{verbatim}
\line
book:loadPackage("twoside", { oddPageFrameID = "r", evenPageFrameID = "l" });
book:declareMirroredFrame("l","r")
book:declareMirroredFrame("lRH","rRH")
\line
\end{verbatim}

Since we will be inheriting from the book class, we will have all
these definitions already available to us. All we need to do is set
up our new class, and then define what is different about it. Here is
how we set up the inheritance:

\begin{verbatim}
\line
local book = SILE.require("classes/book")
local bringhurst = book { id = "bringhurst" }
...
return bringhurst
\line
\end{verbatim}

Now we need to define our frames. 

The LaTeX memoir class’ \em{A Few Notes
On Book Design} tells us that Bringhurst’s book has a spine margin one thirteenth
of the page width; a top margin eight-fifths of the spine margin; a front margin 
and bottom margin both sixteen-fifths of the spine margin. We can define this in SILE
terms like so:

\begin{verbatim}
\line
bringhurst:declareFrame("r", \{
  left = "width(page)/13",
  top = "left(r) * 8 / 5",
  right = "100\% - 2*top(r)",
  bottom = "top(footnotes)"
\})
bringhurst:declareFrame("footnotes", \{
  left="left(r)", 
  right = "right(r)",
  height = "0",
  bottom = "100\% - 2*top(r)"
\})
\line
\end{verbatim}

We are nearly finished!

If we try this class as-is, we’ll
actually find that the running headers are too high, because the textblock is
higher on the page than the standard book class, and the running heads are
defined relative to them.

So, we need to also declare the running header frame to bring them down a bit
lower:

\begin{verbatim}
\line
bringhurst:declareFrame("rRH", \{
  left = "left(r)",
  right = "right(r)",
  top = "top(r) - 4\%",
  bottom = "top(r)-2\%"
\});
\line
\end{verbatim}

If all we want to do in our new class is to create a different page shape, 
this is all we need.

\section{Defining Commands}

However, it’s usually the case that a class will want to do more than
just change the page shape; a class will typically want to do some other things
as well: define additional commands, alter the output routine, store and
investigate bits of state information, and so on. We’ll look briefly
at some of the principles involved in those things here, and in the next
chapters will run through some worked examples.

To define your own command at the Lua level, you use the \code{SILE.registerCommand}
function. It takes two parameters, a command name, and a function. The
signature of a function representing a SILE command is fixed: you need
to take two parameters, \code{options} and \code{content} (of course you
can name your parameters whatever you like, but these are the most common
names). Both of these parameters are Lua tables. The \code{options} parameter
contains the command’s parameters or XML attributes as a key-value table, 
and the \code{content}
is an abstract syntax tree reflecting the input being currently processed.

So in the case of \code{\\mycommand[size=12pt]\{Hello \\break world\}},
the first parameter will contain the table \code{\{size = "12pt"\}} and
the second parameter will contain the table

\begin{verbatim}
\line
{
  "Hello ", 
  {
    attr = {},
    id = "command",
    pos = 8,
    tag = "break"
  }, 
  " world"
}\line
\end{verbatim}

Most commands will find themselves doing something with the \code{options}
and/or calling \break\code{SILE.process(content)} to recursively process the
argument. Here’s a very simple example; an XML \code{<link>} tag may take
an XLink \code{xl:href} attribute\footnote{Yes, I know the document author
might choose a different XML namespace to refer to XLink. Let’s keep things
simple.} We want to render \code{<link xl:href="http://...">Hello</link>}
as \examplefont{Hello (\code{http://...})}. So, first we need to render
the content, and then we need to do something with the attribute:

\begin{verbatim}
\line
SILE.registerCommand("link", function(options, content)
  SILE.process(content)
  if (options["xl:href"]) then
    SILE.typesetter:typeset(" (")
    SILE.call("code", {}, {options["xl:href"]})
    SILE.typesetter:typeset(")")
  end
end)
\line
\end{verbatim}

We use the usual \code{SILE.typesetter:typeset} and \code{SILE.call} 
functions to output text and call other commands.

\note{If you do need to do something with a dimension, you can use 
\code{SILE.toPoints} to parse a basic length and 
\code{SILE.parseComplexFrameDimension} to parse a frame dimension, and turn
them into points.}

\section{Output Routines}

As well as defining frames and packages, different classes also alter
the way that SILE performs its output–what it should do at the start or
end of a page, for instance, which controls things like swapping between
different master frames, displaying page numbers, and so on.

The key methods for defining the \em{output routine} are:

\noindent{}• \code{newPar} and \code{endPar} are called at the start and end of each
paragraph.

\noindent{}• \code{newPage} and \code{endPage} are called at the start
and each of each page.

\noindent{}• \code{init} and \code{finish} are called at the start and
end of the document.

Once again this is done in an object-oriented way, with derived classes
overriding their superclass’ methods where necessary.

When you are loading packages which affect the output routine, the composition of
such packages into a class is not completely automatic\footnote{Because the
order of events is sometimes significant}; in other words, loading the package
will not necessarily by itself change the output routines. You need to 
explicitly plug the various features provided by those packages into the output routine
yourself.

So, for instance, the \code{footnote} or \code{insertions} packages 
provide a \code{outputInsertions} method which needs to be called at the end 
of each page. If you want to build a document class that inherits from \code{plain}
but also has footnote functionality, you will want your \code{endPage} method
to look like this:

\begin{verbatim}
\line
myClass.endPage = function(self)
  myClass:outputInsertions()
  plain.endPage(self)
end
\line
\end{verbatim}

Let’s demonstrate roughly how the \code{tableofcontents} package works. We’ll
be using the \code{infonodes} package to collect the information about which
pages contain table of content items.

First, we set up our infonodes by creating a command that can be called
by sectioning commands. In other words, \code{\\chapter}, \code{\\section}, etc.
should call \code{\\tocentry} to store the page reference for this section.

\begin{verbatim}
\line
SILE.registerCommand("tocentry", function (options, content)
  SILE.call("info", \{
    category = "toc",
    value = \{
      label = content, level = (options.level or 1)
    \}
  \})
end)
\line
\end{verbatim}

Infonodes work on a per-page basis, so if we want to save them throughout
the whole document, at the end of each page we need to move them from the 
per-page table to our own 
table. We also need to make sure we store their page numbers!

\note{SILE provides the \code{SILE.scratch} variable for you to store
global information in; you should use a portion of this table namespaced to
your class or package.}

So, here is a routine we can call at the end of each page to move the
TOC nodes.

\begin{verbatim}
\line
SILE.scratch.tableofcontents = { }

\% Gather the tocentries into a big document-wide TOC
local moveNodes = function(self)
  local n = SILE.scratch.info.thispage.toc
  for i=1,#n do 
    n[i].pageno = SILE.formatCounter(SILE.scratch.counters.folio)
    table.insert(SILE.scratch.tableofcontents, n[i])
  end
end
\line
\end{verbatim}

We’re going to take the LaTeX approach of storing these items out as a
separate file, then loading them back in again when typesetting the TOC.
So at the end of the document, we serialize the \code{SILE.scratch.tableofcontents}
table to disk. Here is a function to be called by the \code{finish} output
routine.

\begin{verbatim}
\line
local writeToc = function (self)
  local t = std.string.pickle(SILE.scratch.tableofcontents)
  saveFile(t, SILE.masterFileName .. '.toc')
end
\line
\end{verbatim}

And then the \code{\\tableofcontents} command reads that file if it is
present, and typesets the TOC nodes appropriately:

\begin{verbatim}
\line
SILE.registerCommand("tableofcontents", function (options, content)
  local toc = loadFile(SILE.masterFileName .. '.toc')
  if not toc then
    SILE.call("tableofcontents:notocmessage")
    return
  end
  SILE.call("tableofcontents:header")
  for i = 1,#toc do
    local item = toc[i]
    SILE.call("tableofcontents:item", {level = item.level, pageno= item.pageno}, item.label)
  end
end)
\line
\end{verbatim}

And the job is done. Well, nearly. The \code{tableofcontents} package now contains a
couple of functions–\code{moveNodes} and \code{writeToc}–that need to be called at 
various points in the output routine of a class which uses this package. How do we
do that?

\section{Exports}

Packages which are primarily used for providing functionality to other classes
and packages need a way of supplying these composible bits of functionality to
the code which is going to use them. This is called the \em{export mechanism}.

As well as defining commands, each package may also return a Lua table consisting
of two entries, \code{init} and \code{exports}.

\code{init} allows you to perform some initialization actions, optionally
based on arguments supplied by the loading class. When the
package is loaded with \code{class:loadPackage(package, args)}, the initializer
is called with two arguments, \code{class} and \code{args}. For instance, the
\code{twoside} package receives information about the IDs of the main right
and left master frames so that it can set up the code to switch masters on page change.
In our case, we will want to ensure that the \code{infonode} package is loaded into
our caller:

\begin{verbatim}
\line
init = function (caller)
  caller:loadPackage("infonode")
end
\line
\end{verbatim}
\chapter{Advanced Class Files 1: SILE As An XML Processor}
\chapter{Advanced Class Files 2: The Discovery Bible}

\end{document}