\begin{document}
\chapter{SILE Packages}

SILE comes with a number of packages which provide additional functionality.
In fact, the actual “core” of SILE’s functionality is very small and very
extensible, with most of the interesting features being provided by add-on
packages. SILE packages are written in the Lua programming language, and can
define new commands, change the way that the SILE system operates, or indeed
do anything that it’s possible to do in Lua.

As mentioned above, loading a package is done through the \code{\\script} command,
which runs Lua code. By convention packages live in the \code{packages/} subdirectory
of either your input file's location, your current working directory or SILE’s
installation directory. For instance, we’ll soon be talking about the
\code{grid} package, which normally can be found as
\code{/usr/local/lib/sile/packages/grid.lua}. To load this, we’d say:

\begin{verbatim}
\line
\\script[src=packages/grid]
\line
\end{verbatim}

\note{\notehead{How SILE locates files} SILE searches for paths in a variety of
directories: first, in the directory in which your input file is located,
then the current wording directory; next, if the environment variable
\code{SILE_PATH} is set, it will look in that directory; then it will look in
the standard installation directories \code{/usr/lib/sile} and
\code{/usr/local/lib/sile}. Unlike TeX, it does not descend into subdirectories
when looking for a file, and so if you have arranged your personal macro, class
or package files into subdirectories, you will need to provide a full relative
path to them.}

\section{image}

As well as processing text, SILE can also include images.

Loading the \code{image} package gives you the \code{\\img} command, fashioned
after the HTML equivalent. \code{\\img} takes the following parameters:
\code{src=\dots} must be the path to an image file;
you may also give \code{height=\dots} and/or \code{width=\dots} parameters
to specify the output size of the image on the paper. If the size parameters
are not given, then the image will be output at its ‘natural’ pixel size.

\begin{note}
With the libtexpdf backend (the default), the images can be in JPEG, PNG,
EPS or PDF formats.
\end{note}

Here is a 200x243 pixel image output with \code{\\img[src=documentation/gutenberg.png]}:\par
\img[src=documentation/gutenberg.png]

\raggedright{
Here it is with (respectively)
\code{\\img[src=documentation/gutenberg.png,width=120px]},
\code{\\img[src=documentation/gutenberg.png,height=200px]}, and
\code{\\img[src=documentation/gutenberg.png,width=120px,height=200px]}:}

\img[src=documentation/gutenberg.png,width=120px]
\img[src=documentation/gutenberg.png,height=200px]
\img[src=documentation/gutenberg.png,width=120px,height=200px]

Notice that images are typeset on the baseline of a line of text, rather like
a very big letter.

\section{folio}
\package-documentation[src=packages/folio]

\section{rules}
\package-documentation[src=packages/rules]

\section{color}
\package-documentation[src=packages/color]

\section{background}
\package-documentation[src=packages/background]

\section{rotate}
\package-documentation[src=packages/rotate]

\section{features}
\package-documentation[src=packages/features]

\section{unichar}
\package-documentation[src=packages/unichar]

\section{bidi}
\package-documentation[src=packages/bidi]

\section{pullquote}
\package-documentation[src=packages/pullquote]

\section{raiselower}

If you don’t want your images, rules or text to be placed along
the baseline, you can use the \code{raiselower} package to move them up
and down. (The \code{footnote} package uses this to superscript the
footnote reference numbers.)

It provides two simple commands, \code{\\raise} and \code{\\lower} which
both take a \code{height=\em{<dimension>}} parameter. They will respectively
raise or lower their argument by the given height. The raised or lowered
content will not alter the height or depth of the line.

Here is some text raised by \raise[height=3pt]{three points}; here is
some text lowered by \lower[height=4pt]{four points}.

The previous paragraph was generated by:

\begin{verbatim}
Here is some text raised by \\raise[height=3pt]\{three points\}; here is
some text lowered by \\lower[height=4pt]\{four points\}.
\end{verbatim}

\section{grid}
\grid[spacing=15pt]
In normal typesetting, SILE determines the spacing between lines of type
according to the following two rules:

\noindent• SILE tries to insert space between two successive lines so that their baselines
are separated by a fixed distance called the \code{baselineskip}.

\noindent• If this first rule would mean that the bottom and the top of the lines are less
than two points apart, then they are forced to be two points apart. (This distance
is configurable, and called the \code{lineskip})

The second rule is designed to avoid the situation where the first line has a long
descender (letters such as g, q, j, p, etc.) which abuts a high ascender on the second
line. (k, l, capitals, etc.)

In addition, the \code{baselineskip} contains a certain amount of ‘stretch’, so that
the lines can expand if this would help with producing a page break at an optimal
location, and similarly spacing between paragraphs can stretch or shrink.

The combination of all of these rules means that a line may begin at practically any
point on the page.

An alternative way of typesetting is to require that lines begin at fixed points on
a regular grid. Some people prefer the ‘color’ of pages produced by grid typesetting,
and the method is often used when typesetting on very thin paper as lining up the
lines of type on both sides of a page ensures that ink does not bleed through from
the back to the front. Compare the following examples: on the left, the lines are
guaranteed to fall in the same places on the recto (front) and the verso (back) of
the paper; on the right, no such guarantee is made.

\img[src=documentation/grid-1.png,height=130]
\img[src=documentation/grid-2.png,height=130]

The \code{grid} package alters the way that the SILE’s typesetter operates so that
the two rules above do not apply; lines are always aligned on a fixed grid, and
spaces between paragraphs etc. are adjusted to conform to the grid. Loading the package
adds two new commands to SILE: \code{\\grid[spacing=\em{<dimension>}]} and \code{\\no-grid}.
The first turns on grid typesetting for the remainder of the document; the second turns it off again.

At the start of this section, we issued the command \code{\\grid[spacing=15pt]} to
set up a regular 15-point grid. Here is some text typeset with the grid set up:

\smallskip
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
\smallskip

And here is the same text after we issue \code{\\no-grid}:

\no-grid\smallskip
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\section{linespacing}
\package-documentation[src=packages/linespacing]

\section{verbatim}
\script{SILE.process(SILE.inputs.TeXlike.docToTree(require("packages/verbatim")))}

\section{font-fallback}
\package-documentation[src=packages/font-fallback]

\section{boustrophedon}
\package-documentation[src=packages/boustrophedon]

\section{chordmode}
\package-documentation[src=packages/chordmode]

\section{color-fonts}
\package-documentation[src=packages/color-fonts]

\section{cropmarks}
\package-documentation[src=packages/cropmarks]

\section{date}
\package-documentation[src=packages/date]

\section{debug}
\package-documentation[src=packages/debug]


\section{Packages usually used by other packages}

In addition, there are certain packages that you \em{probably} don’t need
to use directly, as their main job is to provide more
basic functionality to other packages and classes. Classes such as the
\code{book} class compose functionality from different auxiliary packages.

\subsection{footnotes}

For instance, we’ve seen that the \code{book} class allows you to add
footnotes to text with the \code{\\footnote} command. This command is
actually provided by the \code{footnotes} package. The \code{book}
class loads up the package and tells it where to put the footnotes
that are typeset, and the \code{footnotes} package takes care of
formatting the footnotes. It does this by using a number of other
packages that we will describe below.

\subsection{counters}
\package-documentation[src=packages/counters]

\subsection{pdf}
\package-documentation[src=packages/pdf]

\subsection{frametricks}

As we mentioned in the first chapter, SILE uses frames as an indication
of where to put text onto the page. The \code{frametricks} package assists
package authors by providing a number of commands to manipulate frames.

The most immediately useful is \code{\\showframe}. This asks the output
engine to draw a box and label around a particular frame. It takes an optional
parameter \code{id=\em{<frame id>}}; if this is not supplied, the current
frame is used. If the ID is \code{all}, then all frames declared by the
current class are displayed.

It’s possible to define frames such as sidebars which are not connected
to the main text flow of a page. We’ll see how to do that in a later chapter, but
this raises the obvious question: if they’re not part of the text flow, how do we
get stuff into them? \code{frametricks} provides the \command{\\typeset-into}
command, which allows you to write text into a specified frame:

\begin{verbatim}
\line
\\typeset-into[frame=sidebar]\{ ... frame content here ... \}
\line
\end{verbatim}

\code{frametricks} also provides a number of commands which, to be perfectly
honest, we \em{thought} were going to be useful, but haven’t quite ended up
being as useful as all that.

\breakframevertical\par
The command \code{\\breakframevertical} breaks the current frame in two
at the specified location into an upper and lower frame. If the frame initially had the ID
\code{main}, then \code{main} becomes the upper frame (before the command)
and the lower frame (after the command) is called \code{main_}. We just
issued a \code{\\breakframevertical} command at the start of this paragraph,
and now we will issue the command \code{\\showframe}. \showframe As you can
see, the current frame is called
\code{\script{SILE.typesetter:typeset(SILE.typesetter.frame.id)}}
and now begins at the start of the paragraph.

Similarly, the \code{\\breakframehorizontal} command breaks the frame in two
into a left and a right frame.
The command takes an optional argument \code{offset=<dimension>}, specifying
where on the line the frame should be split. If it is not supplied, the
frame is split at the current position in the line.

The command \code{\\shiftframeedge} allows you to reposition the current
frame left or right. It takes \code{left=} and/or \code{right=} parameters,
which can be positive or negative dimensions. It should only be used at the
top of a frame, as it reinitializes the typesetter object.

\float[bottomboundary=4ex]{\font[size=60pt]{C}}\noindent{}ombining all of these commands, the \code{\\float}
command breaks the current frame, creates a small frame to hold a floating
object (like the dropcap at the start of this sentence), flows text into
the surrounding frame, and then, once text has descended past the floating object,
moves the frame back into place again. It takes two optional parameters, \code{bottomboundary=\em{<dimension>}} and/or \code{rightboundary=\em{<dimension>}}, which
open up additional space around the frame. At the start of this paragraph, I issued
the command

\medskip
\begin{verbatim}
\\float[bottomboundary=5pt]\{\\font[size=60pt]\{C\}\}.
\end{verbatim}

To reiterate: we started playing around with frames like this in the early
days of SILE and they have not really proved a good solution to the things
we wanted to do with them. They’re great for arranging where content should
live on the page, but messing about with them dynamically seems to create
more problems than it solves. There’s probably a reason why InDesign and
similar applications handle floats, drop caps, tables and so on inside the
context of a content frame rather than by messing with the frames themselves.
If you feel tempted to play with \code{frametricks}, there’s almost always
a better way to achieve what you want without it.

\subsection{insertions}

The \code{footnotes} package works by taking auxiliary material (the
footnote content), shrinking the current frame and inserting it into the
footnote frame. This is powered by the \code{insertions} package; it doesn’t
provide any user-visible SILE commands, but provides Lua functionality to
other packages. TeX wizards may be interested to realise that insertions are
implemented by an external add-on package, rather than being part of the SILE core.

\subsection{twoside}

The \code{book} class described in chapter 4 sets up left and right mirrored
page masters; the \code{twoside} package is responsible for swapping between
the two left and right frames, running headers and so on. It has no user-serviceable
parts.

\subsection{masters}

The masters functionality is also itself an add-on package. It allows a class to
define sets of frames and switch between them either temporarily or permanently.
It defines the commands \command{\\define-master-template} (which is pattern
on the \command{\\pagetemplate} function we will meet in chapter 8), \command{\\switch-master}
and \command{\\switch-master-one-page}. See \code{tests/masters.sil} for more
about this package.

\subsection{infonode}

\note{This package is only for class designers.}

While typesetting a document, SILE first breaks a paragraph into lines, then
arranges lines into a page, and later outputs the page. In other words,
while it is looking at the text of a paragraph, it is not clear what page
the text will eventually end up on. This makes it difficult to produce
indexes, tables of contents and so on where one needs to know the page number
for a particular element.

To get around this problem, the \code{infonode} allows you to insert \em{information
nodes} into the text stream; when a page is outputted, these nodes are collected into
a list, and a class’s output routine can examine this list to determine which nodes
fell on a particular page. \code{infonode} provides the \code{\\info} command
to put an information node into the text stream; it has two required parameters,
\code{category=} and \code{value=}. Categories are used to group similar sets of
node together.

As an example, when typesetting a Bible, you may wish to display which range
of verses are on each page as a running header. During the command which starts
a new verse, you would insert an information node with the verse reference:

\begin{verbatim}
\line
SILE.call("info", { category = "references", value = ref }, {})
\line
\end{verbatim}

During the \code{endPage} method which is called at the end of every page,
we look at the list of “references” information nodes:

\begin{verbatim}
\line
local refs = SILE.scratch.info.thispage.references
local runningHead = SILE.shaper.shape(refs[1] .. " - " .. refs[#refs])
SILE.typesetNaturally(rhFrame, runningHead);
\line
\end{verbatim}

\subsection{inputfilter}
\package-documentation[src=packages/inputfilter]

\subsection{break-firstfit}
\package-documentation[src=packages/break-firstfit]

\subsection{chapterverse}
\package-documentation[src=packages/chapterverse]

\section{Experimental packages}

\subsection{balanced-frames}
\package-documentation[src=packages/balanced-frames]

\subsection{bibtex}
\package-documentation[src=packages/bibtex]

\section{The Package Manager}

While your SILE installation will include a comprehensive collection
of SILE packages, there’s more out there! SILE comes with a simple
package manager which can help you to download and install new packages.
The package manager is accessed from the SILE REPL, like so:

\begin{verbatim}
\line
 $ sile
This is SILE 0.9.5.1
> installPackage("endnotes")
Loading catalogue from https://raw.githubusercontent.com/simoncozens/sile-packages/master/packages.lua
\line
\end{verbatim}

There will then follow a load of information which should end up with
the \code{endnotes} package and all its dependencies being installed.
SILE will also ensure that downloaded packages are added to the package
search path. There’s currently no way to list or search the available
packages. We’ll get there.

\end{document}
