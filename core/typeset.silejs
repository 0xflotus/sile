if (!SILE._internals) SILE._internals = {}

SILE._internals.setpar = function (t) {
	t = t.replace(/\n/g, " ");
	if (!SILE.typesetterState.nodes.length) {
		SILE.nodefactory.pushHbox({ width: 0, value: {glyph: 0} });
		SILE.documentState.documentClass.newPar();
	}
	SILE.typesetterState.nodes = SILE.typesetterState.nodes.concat(SILE.shaper.shape(t));
}


SILE.typeset = function (text) {
    text.split(/(\n\n)/).forEach( function(t) {
    	if (t == "\n\n") {
            SILE._internals.leaveHmode();
    		SILE.nodefactory.pushVglue({height: 0, stretch: 1});
    	} else {
    		SILE._internals.setpar(t);
	    }
    });
}

SILE._internals.leaveHmode = function() {
    nl = SILE.typesetterState.nodes;
    while (nl.length > 0 && (nl[nl.length-1].isPenalty() || nl[nl.length-1].isGlue())) {
        nl.pop();
    }
    while (nl.length >0 && nl[0].isPenalty()) nl.shift();

    SILE.nodefactory.pushGlue({ width:0, stretch: 10000 });
    SILE.nodefactory.pushPenalty({ flagged: 1, penalty: -Infinity });
    // Run the KP algorithm
    var breaks = SILE.linebreak(SILE.typesetterState.nodes,[ SILE.typesetterState.currentFrame.width() ]);
    var lines = SILE._breakpointsToLines(breaks);
    
    // Push output lines into boxes and ship them to the page builder
    //console.log("Lines in this para: "+lines.length)
    lines.forEach(function (l, index) {
        var v = SILE.nodefactory.newVbox({ nodes: l.nodes, ratio: l.ratio });
        // Insert leading
        var d = SILE.documentState.documentClass.state.baselineSkip.height - v.height - SILE.typesetterState.frameTotals.prevDepth ;
        //console.log("Leading height = "+SILE.documentState.documentClass.typesetterState.baselineSkip.height+ " - "+v.height + " - " + SILE.typesetterState.frameTotals.prevDepth + " = "+d) ;
        SILE.nodefactory.pushVglue({height: d, stretch: SILE.documentState.documentClass.state.baselineSkip.stretch, shrink: SILE.documentState.documentClass.state.baselineSkip.shrink });
        SILE.nodefactory.pushVbox(v);
        SILE.typesetterState.frameTotals.prevDepth = v.depth;

        // Insert page break penalty
            SILE.nodefactory.pushVpenalty({ penalty: (index == 0 ? SILE.documentState.documentClass.settings.widowPenalty :
                                                  index == lines.length-1 ? SILE.documentState.documentClass.settings.clubPenalty : 0)});
    });
    SILE._pageBuilder();
    //SILE._typeset(lines); // XXX hack
}

SILE.typesetterState.lastBadness = Infinity;

SILE._pageBuilder = function () {
    var target = SILE.typesetterState.currentFrame.bottom() - SILE.typesetterState.currentFrame.top(); // XXX
    var vbox;
    while (SILE.typesetterState.outputQueue.length > 0 && (vbox = SILE.typesetterState.outputQueue.shift())) {
        if (vbox.isVbox() || vbox.isVglue()) {
            SILE.typesetterState.frameTotals.height += vbox.height + vbox.depth;
        }
        var left = target - SILE.typesetterState.frameTotals.height;
        if (vbox.isPenalty()) {
            var badness = left > 0 ? left * left * left : 10000;
            var c = badness < 10000 ? vbox.penalty + badness : 10000;
            if (c > SILE.typesetterState.lastBadness) {
                SILE.shipOut(target);
                SILE.typesetterState.lastBadness = Infinity;
            } else {
                SILE.typesetterState.lastBadness = c;
            }
        }
        SILE.typesetterState.frameLines.push(vbox);
    }
};

SILE.shipOut = function (target, independent) {
    //console.log("Height total is " + SILE.typesetterState.frameTotals.height);
    //console.log("Target is "+target);
    var adjustment = target - SILE.typesetterState.frameTotals.height;
    var glues = [];
    SILE.typesetterState.frameLines.forEach(function (b) { 
        if (b.isVglue()) glues.push(b);
    });
    var totalStretch = 0;
    //console.log("Vglues: "+glues.length)
    if (glues.length) totalStretch = glues.map(function (g) { return g.stretch; }).reduce(function(a,b) { return a+b; });
    //console.log("Total stretch: "+totalStretch);
    //console.log("Adjustment needed: "+adjustment);
    if (adjustment > totalStretch) adjustment = totalStretch;
    if (adjustment / totalStretch > 0) glues.map(function (g) { g.setGlue(g.stretch * adjustment / totalStretch); });
    //console.log("Glues for this page adjusted by "+(adjustment/totalStretch) )
    SILE._typeset(SILE.typesetterState.frameLines)
    SILE.typesetterState.frameLines = [];
    //SILE.typesetterState.frameTotals.height = 0;
    //SILE.typesetterState.frameTotals.prevDepth = 0;
    if (!independent) {
        if (SILE.typesetterState.currentFrame.next) {
            SILE.baseClass.initFrame(SILE.typesetterState.currentFrame.next); // XXX ?
        } else {
            SILE.documentState.documentClass.newPage(); // XXX Hack
        }
    }
};

SILE._typeset = function (lines) { 
    // ALL HACKS
    var thisFrame = SILE.typesetterState.currentFrame;

    lines.forEach(function(line) {
        if (line.isVglue()) {
            SILE.typesetterState.cursorY += line.depth + line.height;
            return;
        }
        if (!line.nodes) return;
        //console.log("Line: " +line.nodes.map(function(x) { return x.toS() }).join(" "));
        line.nodes.forEach(function(node) {
            if (node.isPenalty()) return;
            if (node.isGlue()) {
                SILE.typesetterState.cursorX += node.width + line.ratio * (line.ratio < 0 ? node.shrink : line.ratio > 0 ? node.stretch : 0);
            } else {
                if (node.value.glyph == 0) return;
                SILE.cairo.moveTo(SILE.typesetterState.cursorX, SILE.typesetterState.cursorY);
                SILE.cairo.showAGlyph(node.value.font, node.value.rawGlyph);
                SILE.typesetterState.cursorX += (node.width + line.ratio * (line.ratio < 0 ? node.shrink : node.stretch));
                //console.log("Width: "+node.width);
                //console.log("Ratio: "+line.ratio);

            }
        })
        SILE.typesetterState.cursorX = SILE.typesetterState.currentFrame.left()
        SILE.typesetterState.cursorY += line.depth + line.height;
    });
}

SILE._breakpointsToLines = function(bp){
    var linestart = 0;
    var lines = [];
    var nodes = SILE.typesetterState.nodes;

    bp.forEach(function(point) {
        if (point.position == 0) return;
        for (j = linestart; j < nodes.length; j++) {
            if (nodes[j].isBox() || (nodes[j].isPenalty && nodes[j].penalty == -Infinity)) {
                linestart = j; break;
            }
        }
        lines.push({ ratio: point.ratio, nodes: nodes.slice(linestart, point.position) })
        linestart = point.position;
    });
    //SILE.typesetterState.nodes = nodes.slice(linestart+1,nodes.length);
    SILE.typesetterState.nodes = [];
    return lines;
}
