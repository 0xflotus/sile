if (!SILE._internals) SILE._internals = {}

SILE._internals.setpar = function (t) {
	t = t.replace(/\n/g, " ");
	if (!SILE.state.nodes.length) {
		SILE.nodefactory.pushHbox({ width: 0, value: {glyph: 0} });
		SILE.state.documentClass.newPar();
	}
	SILE.state.nodes = SILE.state.nodes.concat(SILE.shaper.shape(t));
}


SILE.typeset = function (text) {
    text.split(/(\n\n)/).forEach( function(t) {
    	if (t == "\n\n") {
            SILE._internals.leaveHmode();
    		SILE.nodefactory.pushVglue({height: 0, stretch: 1});
    	} else {
    		SILE._internals.setpar(t);
	    }
    });
}

SILE._internals.leaveHmode = function() {
    nl = SILE.state.nodes;
    while (nl.length > 0 && (nl[nl.length-1].isPenalty() || nl[nl.length-1].isGlue())) {
        nl.pop();
    }
    while (nl.length >0 && nl[0].isPenalty()) nl.shift();

    SILE.nodefactory.pushGlue({ width:0, stretch: 10000 });
    SILE.nodefactory.pushPenalty({ flagged: 1, penalty: -Infinity });
    // Run the KP algorithm
    var breaks = SILE.linebreak(SILE.state.nodes,[ SILE.state.currentFrame.width() ]);
    var lines = SILE._breakpointsToLines(breaks);
    
    // Push output lines into boxes and ship them to the page builder
    lines.forEach(function (l, index) {
        SILE.nodefactory.pushVbox({ nodes: l.nodes, ratio: l.ratio });
        SILE.nodefactory.pushVpenalty({ penalty: (index == 0 ? SILE.state.documentClass.settings.widowPenalty :
                                                  index == lines.length-1 ? SILE.state.documentClass.settings.clubPenalty : 0)});
    });
    SILE._pageBuilder();
    //SILE._typeset(lines); // XXX hack
}

SILE._pageBuilder = (function () {
    var lastBadness = Infinity;
    return function() {
        target = SILE.state.currentFrame.bottom() - SILE.state.currentFrame.top(); // XXX
        var vbox;
        while (SILE.state.outputQueue.length > 0 && (vbox = SILE.state.outputQueue.shift())) {
            if (vbox.isVbox() || vbox.isVglue()) {
                SILE.state.frameTotals.height += vbox.height + vbox.depth;
            }
            var left = target - SILE.state.frameTotals.height;
            if (vbox.isPenalty()) {
                var badness = left > 0 ? left * left * left : 10000;
                var c = badness < 10000 ? vbox.penalty + badness : 10000;
                if (c > lastBadness) {
                    SILE.shipOut(target);
                    lastBadness = Infinity;
                } else {
                    lastBadness = c;
                }
            }
            SILE.state.frameLines.push(vbox);
        }
    }
})();

SILE.shipOut = function (target) {
    console.log("shipOut");
    var adjustment = SILE.state.frameTotals.height - target;
    var glues = [];
    SILE.state.frameLines.forEach(function (b) { 
        if (b.isVglue()) glues.push(b);
    });
    var totalStretch = 0;
    if (glues.length) totalStretch = glues.map(function (g) { return g.stretch; }).reduce(function(a,b) { return a+b; });
    if (adjustment > totalStretch) adjustment = totalStretch;
    glues.map(function (g) { g.setGlue(g.stretch / totalStretch * adjustment); });
    SILE._typeset(SILE.state.frameLines)
    SILE.state.frameLines = [];
    SILE.state.frameTotals.height = 0;
    if (SILE.state.currentFrame.next) {
        console.log("There's another frame!")
        SILE.baseClass.initFrame(SILE.state.currentFrame.next); // XXX ?
    } else {
        SILE.state.documentClass.newPage(); // XXX Hack
    }
};

SILE._typeset = function (lines) { 
    // ALL HACKS
    var thisFrame = SILE.state.currentFrame;

    lines.forEach(function(line) {
        SILE.state.cursorY += line.depth + line.height;
        if (!line.nodes) return;
        //console.log("Line: " +line.nodes.map(function(x) { return x.toS() }).join(" "));
        line.nodes.forEach(function(node) {
            if (node.isPenalty()) return;
            if (node.isGlue()) {
                SILE.state.cursorX += node.width + line.ratio * (line.ratio < 0 ? node.shrink : line.ratio > 0 ? node.stretch : 0);
            } else {
                if (node.value.glyph == 0) return;
                SILE.cairo.moveTo(SILE.state.cursorX, SILE.state.cursorY);
                SILE.cairo.showAGlyph(node.value.font, node.value.rawGlyph);
                SILE.state.cursorX += (node.width + line.ratio * (line.ratio < 0 ? node.shrink : node.stretch));
                //console.log("Width: "+node.width);
                //console.log("Ratio: "+line.ratio);

            }
        })
        SILE.state.cursorX = SILE.state.currentFrame.left()
    });
}

SILE._breakpointsToLines = function(bp){
    var linestart = 0;
    var lines = [];
    var nodes = SILE.state.nodes;

    bp.forEach(function(point) {
        if (point.position == 0) return;
        for (j = linestart; j < nodes.length; j++) {
            if (nodes[j].isBox() || (nodes[j].isPenalty && nodes[j].penalty == -Infinity)) {
                linestart = j; break;
            }
        }
        lines.push({ ratio: point.ratio, nodes: nodes.slice(linestart, point.position) })
        linestart = point.position;
    });
    //SILE.state.nodes = nodes.slice(linestart+1,nodes.length);
    SILE.state.nodes = [];
    return lines;
}
