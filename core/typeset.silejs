/* This is the default typesetter. You are, of course, welcome to create your own. */

SILE.typesetter = {
  /* Setup functions */
  init: function(frame) {
    this.initState();
    this.stateQueue = [];
    this.initFrame(frame);
    return this;
  },
  initFrame: function(f) {
    this.frame = f;
    this.state.cursorX = this.frame.left();
    this.state.cursorY = this.frame.top();
    this.state.frameTotals = { height: 0, prevDepth: 0 };
  },
  initState: function() {
    this.state = {
      nodes: [],
      outputQueue: [],
      lastBadness: Infinity,
      frameTotals: { height: 0, prevDepth: 0, },
      frameLines: []
    };
  },
  pushState: function() {
    this.stateQueue.push(this.state);
    this.initState();
  },
  popState: function() {
    this.state = this.stateQueue.pop();
  },

  /* Boxy stuff */
  pushHbox: function (spec) { this.state.nodes.push(SILE.nodefactory.newHbox(spec)); },
  pushGlue: function (spec) { return this.state.nodes.push(SILE.nodefactory.newGlue(spec)); },
  pushPenalty: function (spec) {  return this.state.nodes.push(SILE.nodefactory.newPenalty(spec)); },
  pushVbox: function (spec) { var x;this.state.outputQueue.push(x = SILE.nodefactory.newVbox(spec)); return x; },
  pushVglue: function (spec) { return this.state.outputQueue.push(SILE.nodefactory.newVglue(spec)); },
  pushVpenalty: function (spec) { return this.state.outputQueue.push(SILE.nodefactory.newPenalty(spec)); },

  /* Actual typesetting functions */
  typeset: function (text) {
    var that=this;
    text.split(/(\n\n)/).forEach( function(t) {
      if (t == "\n\n") {
        that.leaveHmode();
        //that.pushVglue({height: 0, stretch: 1});
      } else {
        that.setpar(t);
      }
    });
  },
  setpar: function (t) {
    t = t.replace(/\n/g, " ");
    if (!this.state.nodes.length) {
      this.pushHbox({ width: 0, value: {glyph: 0} });
      SILE.documentState.documentClass.newPar(this); // XXX ?
    }
    this.state.nodes = this.state.nodes.concat(SILE.shaper.shape(t));
  },
  leaveHmode: function() {
    var that = this;
    //console.log("Leaving hmode");
    nl = this.state.nodes;
    while (nl.length > 0 && (nl[nl.length-1].isPenalty() || nl[nl.length-1].isGlue())) {
        nl.pop();
    }
    while (nl.length >0 && nl[0].isPenalty()) nl.shift();

    this.pushGlue({ width:0, stretch: 10000 });
    this.pushPenalty({ flagged: 1, penalty: -Infinity });
    // Run the KP algorithm
    var breaks = SILE.linebreak(this.state.nodes,[ this.frame.width() ]);
    var lines = this.breakpointsToLines(breaks);
    
    // Push output lines into boxes and ship them to the page builder
    lines.forEach(function (l, index) {
      var v = SILE.nodefactory.newVbox({ nodes: l.nodes, ratio: l.ratio });
      // Insert leading
      var d = SILE.documentState.documentClass.state.baselineSkip.height - v.height - that.state.frameTotals.prevDepth ;
      console.log("Leading height = "+SILE.documentState.documentClass.state.baselineSkip.height+ " - "+v.height + " - " + that.state.frameTotals.prevDepth + " = "+d) ;

      that.pushVbox(v);
      that.state.frameTotals.prevDepth = v.depth;
      var pageBreakPenalty = (index == 0 ? SILE.documentState.documentClass.settings.widowPenalty :
                                                index == lines.length-1 ? SILE.documentState.documentClass.settings.clubPenalty : 0);
      // Insert page break penalty
      if (lines.length > 1)
          that.pushVpenalty({ penalty: pageBreakPenalty});
      else 
          that.pushVpenalty({ penalty: 0 });
      if (d > SILE.documentState.documentClass.state.lineSkip.height) {
          that.pushVglue({height: d, stretch: SILE.documentState.documentClass.state.baselineSkip.stretch, shrink: SILE.documentState.documentClass.state.baselineSkip.shrink });
      } else {
          that.pushVglue(SILE.documentState.documentClass.state.lineSkip);
      }        
    });
    this.pageBuilder();
  },
  pageBuilder: function () {
    var target = this.frame.height(); // XXX Floats
    var vbox;
    while (this.state.outputQueue.length > 0 && (vbox = this.state.outputQueue.shift())) {
      //console.log("Dealing with VBox "+vbox.toS())
      if (vbox.isVbox() || vbox.isVglue()) {
        this.state.frameTotals.height += vbox.height + vbox.depth;
      }
      var left = target - this.state.frameTotals.height;
      //console.log("I have "+left+"pts left");
      if (vbox.isPenalty()) {
        var badness = left > 0 ? left * left * left : 10000;
        var c = badness < 10000 ? vbox.penalty + badness : 10000;
        //console.log("Badness: "+c);
        if (c > this.state.lastBadness) {
          //console.log("This is worse");
          this.state.lastBadness = Infinity;
          this.shipOut(target);
        } else {
          this.state.lastBadness = c;
        }
      }
      this.state.frameLines.push(vbox);
    }
  },

  shipOut: function (target, independent) {
    //console.log("Height total is " + this.state.frameTotals.height);
    //console.log("Target is "+target);
    var adjustment = target - this.state.frameTotals.height;
    var glues = [];
    this.state.frameLines.forEach(function (b) {
      if (b.isVglue()) glues.push(b);
    });
    var totalStretch = 0;
    //console.log("Vglues: "+glues.length)
    if (glues.length) totalStretch = glues.map(function (g) { return g.stretch; }).reduce(function(a,b) { return a+b; });
    //console.log("Total stretch: "+totalStretch);
    //console.log("Adjustment needed: "+adjustment);
    if (adjustment > totalStretch) adjustment = totalStretch;
    if (adjustment / totalStretch > 0) glues.map(function (g) { g.setGlue(g.stretch * adjustment / totalStretch); });
    //console.log("Glues for this page adjusted by "+(adjustment/totalStretch) )
    this.outputLinesToPage(this.state.frameLines);
    this.state.frameLines = [];
    //this.state.frameTotals.height = 0;
    //this.state.frameTotals.prevDepth = 0;
    if (!independent) {
        var cwidth = this.frame.width();
        if (this.frame.next) {
          this.initFrame(SILE.getFrame(this.frame.next));
        } else {
          this.initFrame(SILE.documentState.documentClass.newPage()); // XXX Hack
        }
        // XXX Put everything back, because the next frame may have a different shape
        if (this.frame.width() != cwidth) {
          this.pushBack();
        }
    }
  },
  pushBack: function () {
    this.pushHbox({ width: 0, value: {glyph: 0} });
    while ((v = this.state.outputQueue.shift())) {
      if (v.isVglue() || v.isPenalty()) { continue; }
      this.state.nodes = this.state.nodes.concat(v.nodes);
      // XXX Hack - end-of-line glue is tossed by leaveHmode, but now the lines may
      // end in different places. We need to add it back.
      this.state.nodes = this.state.nodes.concat(SILE.shaper.shape(" "));
    }
    this.leaveHmode();
  },
  outputLinesToPage: function (lines) {
    var that = this;
    lines.forEach(function(line) {
      if (line.isVglue()) {
        that.state.cursorY += line.depth + line.height;
        return;
      }
      if (!line.nodes) return;
      that.state.cursorY += line.depth + line.height;

      line.nodes.forEach(function(node) { node.outputYourself(that, line); });
      that.state.cursorX = that.frame.left();
    });
  },
  breakpointsToLines: function(bp){
    var linestart = 0;
    var lines = [];
    var nodes = this.state.nodes;

    bp.forEach(function(point) {
      if (point.position === 0) return;
      for (j = linestart; j < nodes.length; j++) {
        if (nodes[j].isBox() || (nodes[j].isPenalty && nodes[j].penalty == -Infinity)) {
          linestart = j; break;
        }
      }
      lines.push({ ratio: point.ratio, nodes: nodes.slice(linestart, point.position) });
      linestart = point.position;
    });
    //this.state.nodes = nodes.slice(linestart+1,nodes.length);
    this.state.nodes = [];
    return lines;
  }
};