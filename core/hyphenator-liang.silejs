SILE.hyphenator = function() {
    var addPattern = function(h, p) {
        var chars = p.split("").filter(function(x) { return x.match(/\D/) });
        var points = p.split(/\D/).map(function(x) { return parseInt(x) || 0 });
        var t = h.trie;
        chars.map(function(x) {
            if (!t[x]) { t[x] = {} };
            t = t[x];
        });
        t["_"] = points;
    };
    var loadPatterns = function(h, language) {
        if(!language) language = "en";
        var languageset = SILE.hyphenator.languages[language];
        languageset.patterns.forEach(function(p) { addPattern(h, p) });
        languageset.exceptions.forEach(function(x) { 
            h.exceptions[x.replace(/-/g,"")] = [ 0 ].concat(x.split(/[^-]/).map(function(l) { return l == "-" ? 1 : 0}));
        });
    };

    var _hyphenate = function(word) {
        if (word.length < this.minWord) return [word];
        var points = this.exceptions[word.toLowerCase()];
        word = word.split("");
        if (!points) {
            var work = ["." ].concat( word.map(function(s) { return s.toLowerCase() })).concat(["."]);
            var points = [0].concat(work.map(function(x) { return 0 }));
            for (var i = 0; i < work.length; i++) {
                var t = this.trie;
                for (var j = i;j < work.length; j++) {
                    if (!t[work[j]]) break;
                    t = t[work[j]];
                    var p;
                    if (p = t._) {
                        for (k = 0; k < p.length; k++) {
                            if (points[i+k] < p[k]) {
                                points[i+k] = p[k];
                            }
                        }
                    }
                }
            }
            for (var i= 0; i < this.minPrefix + 1; i++) points[i] = 0;
            for (var i= points.length-this.maxPrefix - 1; i < points.length; i++) points[i] = 0;
        }
        var pieces = [''];
        var i;
        for (i =0; i < word.length; i++) {
            pieces[pieces.length-1] = pieces[pieces.length-1] + word[i];
            if (points[2+i] % 2) { pieces.push("") }
        }
        return pieces;
    };
    return function (language) {
        this.minWord = 5; this.minPrefix = 2; this.maxPrefix = 2;
        this.trie = {};
        this.exceptions = {};
        this._hyphenate = _hyphenate;
        loadPatterns(this, language);
    return this;
    }
}();
SILE.hyphenator.languages = [];

SILE.hyphenate = function (typesetter) {
    h = SILE.hyphenator();
    typesetter.state.nodes.forEach(function (n, i, tNodes) {
        if (n.isNNode() && n.text) {
            //console.log("Breaking '"+n.text+"'");
            breaks = h._hyphenate(n.text);
            if (breaks.length > 1) {
                var nodes = [];
                while (breaks[breaks.length-1]=="") breaks.pop();
                //console.log(breaks);
                breaks.forEach(function (b,j,breaks) { 
                    nodes = nodes.concat.apply(nodes, SILE.shaper.shape(b, n.pal));
                    if (j != breaks.length -1) {
                        nodes.push(SILE.nodefactory.newDiscretionary({
                            preBreak: SILE.shaper.shape("-", n.pal)
                        }));
                        nodes.push(SILE.nodefactory.newPenalty({ flagged: 1, penalty: typesetter.state.hypenPenalty }));
                    }
                });
                tNodes.splice.apply(tNodes, [i, 1].concat(nodes));
            }
        }
    });
    //console.log(typesetter.state.nodes.map(function(x) { return x.toS()}));
};