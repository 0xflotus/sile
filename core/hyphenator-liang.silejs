SILE.hyphenator = function(language) {
    var addPattern = function(h, p) {
        var chars = p.split("").filter(function(x) { return x.match(/\D/) });
        var points = p.split(/\D/).map(function(x) { return parseInt(x) || 0 });
        var t = h.trie;
        chars.map(function(x) {
            if (!t[x]) { t[x] = {} };
            t = t[x];
        });
        t["_"] = points;
    };
    var loadPatterns = function(h, language) {
        if(!language) language = "en";
        SILE.require("languages/"+language);
        var languageset = SILE.hyphenator.languages[language];
        if (!languageset) { console.log("No patterns for language "+language); return; }
        languageset.patterns.forEach(function(p) { addPattern(h, p) });
        languageset.exceptions.forEach(function(x) { 
            h.exceptions[x.replace(/-/g,"")] = [ 0 ].concat(x.split(/[^-]/).map(function(l) { return l == "-" ? 1 : 0}));
        });
    };

    var _hyphenate = function(word) {
        if (word.length < this.minWord) return [word];
        var points = this.exceptions[word.toLowerCase()];
        word = word.split("");
        if (!points) {
            var work = ["." ].concat( word.map(function(s) { return s.toLowerCase() })).concat(["."]);
            var points = [0].concat(work.map(function(x) { return 0 }));
            for (var i = 0; i < work.length; i++) {
                var t = this.trie;
                for (var j = i;j < work.length; j++) {
                    if (!t[work[j]]) break;
                    t = t[work[j]];
                    var p;
                    if (p = t._) {
                        for (k = 0; k < p.length; k++) {
                            if (points[i+k] < p[k]) {
                                points[i+k] = p[k];
                            }
                        }
                    }
                }
            }
            for (var i= 0; i < this.minPrefix + 1; i++) points[i] = 0;
            for (var i= points.length-this.maxPrefix - 1; i < points.length; i++) points[i] = 0;
        }
        var pieces = [''];
        var i;
        for (i =0; i < word.length; i++) {
            pieces[pieces.length-1] = pieces[pieces.length-1] + word[i];
            if (points[2+i] % 2) { pieces.push("") }
        }
        return pieces;
    };
    var f = {};
    f.trie = {};
    f.exceptions = {};
    loadPatterns(f, language);
    f.minWord = 5; f.minPrefix = 2; f.maxPrefix = 2;
    f._hyphenate = _hyphenate;
    
    return f;
};
SILE.hyphenator.languages = [];
SILE._hyphenators = {};

SILE.hyphenate = function (typesetter) {
    typesetter.state.nodes.forEach(function (n, i, tNodes) {
        if (n.isNNode() && n.text) {
            if (!SILE._hyphenators[n.language]) SILE._hyphenators[n.language] = SILE.hyphenator(n.language);
            //console.log("Breaking '"+n.text+"' as language "+n.language);
            breaks = SILE._hyphenators[n.language]._hyphenate(n.text);
            //console.log(breaks);
            if (breaks.length > 1) {
                var nodes = [];
                while (breaks[breaks.length-1]=="") breaks.pop();
                //console.log(breaks);
                breaks.forEach(function (b,j,breaks) { 
                    nodes = nodes.concat.apply(nodes, SILE.shaper.shape(b, n.pal, n.language));
                    if (j != breaks.length -1) {
                        nodes.push(SILE.nodefactory.newDiscretionary({
                            preBreak: SILE.shaper.shape("-", n.pal)
                        }));
                        nodes.push(SILE.nodefactory.newPenalty({ flagged: 1, penalty: typesetter.state.hypenPenalty }));
                    }
                });
                tNodes.splice.apply(tNodes, [i, 1].concat(nodes));
            }
        }
    });
    //console.log(typesetter.state.nodes.map(function(x) { return x.toS()}));
};