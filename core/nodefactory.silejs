SILE.nodefactory = (function() {
  var _box = {height: 0, depth: 0, width: 0, stretch: 0, shrink: 0};
  _box.outputYourself = function() { throw "Special with no output routine!"; };
  _box.toText = function () { return "<special>"; };

  var _hbox = object(_box); _hbox.type = "HBox";
  _hbox.toS = function() { return "H<"+this.width+">^"+this.height+"-"+this.depth+"v"; };
  _box.isBox = function () { return this.type === "HBox" || this.type === "NNode"; };
  _hbox.outputYourself = function(typesetter, line) {
    if (this.value.glyph === 0) return;
    var scaledWidth = (this.width + line.ratio * (line.ratio < 0 ? this.shrink : this.stretch));
    //SILE.outputter.debugHbox(typesetter, this, scaledWidth);
    SILE.cairo.moveTo(typesetter.state.cursorX, typesetter.state.cursorY);
    SILE.cairo.showGlyphString(this.value.font, this.value.rawGlyphString);

    typesetter.state.cursorX += scaledWidth;
  };
  _hbox.toText = function() {
    // This only works for fonts with particular cmap tables. If you use
    // Gentium for your debugging it works; maybe not otherwise.
    return this.value ? String.fromCharCode(this.value.glyph+32) : " ";
  }

  var _native_node = object(_box); _native_node.type = "NNode";
  _box.isNNode = function () { return this.type === "NNode"; };
  _native_node.text = "";
  _native_node.pal = null;
  _native_node.language = null;
  _native_node.nodes = [];
  _native_node.outputYourself = function (typesetter, line) {
    this.nodes.forEach(function(n){ n.outputYourself(typesetter, line); });
  };
  _native_node.toText = function () { return this.text; }
  _native_node.toS = function() { return "N<"+this.width+">^"+this.height+"-"+this.depth+"v("+this.toText()+")"; };

  _discretionary = object(_box); _discretionary.type = "Discretionary";
  _box.isDiscretionary = function () { return this.type == "Discretionary"; };
  _discretionary.preBreak = [];
  _discretionary.postBreak = [];
  _discretionary.used = 0;
  _discretionary.toS = function() {return "("+this.preBreak.map(function(x) { return x.toS(); }).join("")+"|"+this.postBreak.map(function(x) { return x.toS(); }).join(""); };
  _discretionary.toText = function() { return "\\-"; };
  _discretionary.outputYourself = function (typesetter,line) {
    var nodes = line.nodes;
    if (this.used == 1) {
      this.preBreak.forEach(function(n){ n.outputYourself(typesetter, line); });
    }
  }

  var _glue = object(_box); _glue.type = "Glue";
  _glue.toS = function() { return "G<"+this.stretch+"|"+this.width+"|"+this.shrink+">"; };
  _box.isGlue = function() { return this.type === "Glue"; };
  _glue.outputYourself = function(typesetter, line) {
    typesetter.state.cursorX += this.width + line.ratio * (line.ratio < 0 ? this.shrink : line.ratio > 0 ? this.stretch : 0);
  };
  _glue.toText = function () { return " "; }

  var _vglue = object(_box); _vglue.type = "VGlue";
  _vglue.toS = function() { return "VG<"+this.stretch+"|"+this.height+"|"+this.shrink+">"; };
  _box.isVglue = function() { return this.type === "VGlue"; };
  _vglue.setGlue = function (adjustment) {
    this.height = this.height + adjustment;
    this.stretch = 0;
  };

  var _penalty = object(_box); _penalty.type = "Penalty"; _penalty.flagged = 0; _penalty.penalty = 0;
  _penalty.toS = function() { return "P("+this.penalty+(this.flagged ? "!":"")+")"; };
  _penalty.toText = function() { return "(!)"; };
  _penalty.outputYourself = function() {};
  _box.isPenalty = function() { return this.type === "Penalty" };

    var _vbox = object(_box); _vbox.type = "VBox";
  _box.isVbox = function () { return this.type === "VBox" };
    _vbox.toS = function() { return "VB["+this.toText()+"]"; }
    _vbox.toText = function() {return this.nodes.map(function(v) { return v.toText() }).join("") };
  _hbox.value = {};
  _vbox.nodes = [];
  _vbox.ratio = 0;

  var _new_and_spec = function (proto, spec) {
    var o = object(proto);
    for (e in proto) { if (spec[e]) o[e] = spec[e] }
    return o;
  };

  return {
    newHbox: function(spec) { return _new_and_spec(_hbox, spec) },
    newDiscretionary: function(spec) { 
      var disc = _new_and_spec(_discretionary, spec);
      disc.prebreakWidth = 0;
      disc.preBreak.forEach(function (n) { disc.prebreakWidth += n.width; });
      return disc;
    },
    newVbox: function(spec) {
      var vbox = _new_and_spec(_vbox, spec);
      // Compute the dimensions
      // console.log(vbox.nodes.map(function (x) { return x.toS() }).join(""));
      vbox.depth = vbox.nodes.select(function(n) { return n.isBox() }).max( function (n) { return n.depth });
      vbox.height = vbox.nodes.select(function(n) { return n.isBox() }).max( function (n) { return n.height });
      // console.log("VBOX H"+vbox.height+" D"+vbox.depth);
      return vbox;
    },
    newNativeNode: function(spec) {
      var nnode = _new_and_spec(_native_node, spec);
      // Compute the dimensions
      // console.log(nnode.nodes.map(function (x) { return x.toS() }).join(""));
      nnode.depth = nnode.nodes.select(function(n) { return n.isBox() }).max( function (n) { return n.depth });
      nnode.height = nnode.nodes.select(function(n) { return n.isBox() }).max( function (n) { return n.height });
      nnode.width = 0;
      nnode.nodes.forEach(function (n) { nnode.width += n.width; });
      // console.log("nnode H"+nnode.height+" D"+nnode.depth);
      return nnode;
    },   
    newGlue: function(spec) { return _new_and_spec(_glue, spec) },
    newVglue: function(spec) { return _new_and_spec(_vglue, spec) },
    newPenalty: function(spec) { return _new_and_spec(_penalty, spec) },
  };
})();
